// Code generated by Prisma Client Rust. DO NOT EDIT

pub static DATAMODEL_STR: &'static str = include_str!(
  "/home/pubudu/dev/git-monitor/git-monitor-backend/prisma/schema.prisma"
);
static DATABASE_STR: &'static str = "sqlite";
pub async fn new_client(
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
  PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
  url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
  PrismaClient::_builder()
    .with_url(url.to_string())
    .build()
    .await
}
pub mod repo {
  use super::_prisma::*;
  use super::*;
  pub const NAME: &str = "Repo";
  pub mod dir {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "dir";
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetDir(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::Dir(v)
      }
    }
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Dir(direction)
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
      UniqueWhereParam::DirEquals(value).into()
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::StringFilter,
      Dir,
      {
        fn in_vec(_: Vec<String>) -> InVec;
        fn not_in_vec(_: Vec<String>) -> NotInVec;
        fn lt(_: String) -> Lt;
        fn lte(_: String) -> Lte;
        fn gt(_: String) -> Gt;
        fn gte(_: String) -> Gte;
        fn contains(_: String) -> Contains;
        fn starts_with(_: String) -> StartsWith;
        fn ends_with(_: String) -> EndsWith;
        fn not(_: String) -> Not;
      }
    );
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Dir(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Dir(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod managed {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "managed";
    pub struct Set(pub bool);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetManaged(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::Managed(v)
      }
    }
    pub fn set<T: From<Set>>(value: bool) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Managed(direction)
    }
    pub fn equals(value: bool) -> WhereParam {
      WhereParam::Managed(_prisma::read_filters::BoolFilter::Equals(value))
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::BoolFilter,
      Managed,
      {
        fn not(_: bool) -> Not;
      }
    );
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Managed(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Managed(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod updated_at {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "updatedAt";
    pub struct Set(
      pub  ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset,
      >,
    );
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetUpdatedAt(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::UpdatedAt(v)
      }
    }
    pub fn set<T: From<Set>>(
      value: ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset,
      >,
    ) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::UpdatedAt(direction)
    }
    pub fn equals(
      value: ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset,
      >,
    ) -> WhereParam {
      WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Equals(
        value,
      ))
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::DateTimeFilter,
      UpdatedAt,
      {
        fn in_vec(
          _: Vec<
            ::prisma_client_rust::chrono::DateTime<
              ::prisma_client_rust::chrono::FixedOffset,
            >,
          >,
        ) -> InVec;
        fn not_in_vec(
          _: Vec<
            ::prisma_client_rust::chrono::DateTime<
              ::prisma_client_rust::chrono::FixedOffset,
            >,
          >,
        ) -> NotInVec;
        fn lt(
          _: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
          >,
        ) -> Lt;
        fn lte(
          _: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
          >,
        ) -> Lte;
        fn gt(
          _: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
          >,
        ) -> Gt;
        fn gte(
          _: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
          >,
        ) -> Gte;
        fn not(
          _: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
          >,
        ) -> Not;
      }
    );
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::UpdatedAt(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::UpdatedAt(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod name {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "name";
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetName(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::Name(v)
      }
    }
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Name(direction)
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::StringFilter,
      Name,
      {
        fn in_vec(_: Vec<String>) -> InVec;
        fn not_in_vec(_: Vec<String>) -> NotInVec;
        fn lt(_: String) -> Lt;
        fn lte(_: String) -> Lte;
        fn gt(_: String) -> Gt;
        fn gte(_: String) -> Gte;
        fn contains(_: String) -> Contains;
        fn starts_with(_: String) -> StartsWith;
        fn ends_with(_: String) -> EndsWith;
        fn not(_: String) -> Not;
      }
    );
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Name(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Name(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod is_valid {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "is_valid";
    pub struct Set(pub bool);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetIsValid(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::IsValid(v)
      }
    }
    pub fn set<T: From<Set>>(value: bool) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::IsValid(direction)
    }
    pub fn equals(value: bool) -> WhereParam {
      WhereParam::IsValid(_prisma::read_filters::BoolFilter::Equals(value))
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::BoolFilter,
      IsValid,
      {
        fn not(_: bool) -> Not;
      }
    );
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::IsValid(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::IsValid(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod state {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "state";
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetState(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::State(v)
      }
    }
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::State(direction)
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::State(_prisma::read_filters::StringFilter::Equals(value))
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::StringFilter,
      State,
      {
        fn in_vec(_: Vec<String>) -> InVec;
        fn not_in_vec(_: Vec<String>) -> NotInVec;
        fn lt(_: String) -> Lt;
        fn lte(_: String) -> Lte;
        fn gt(_: String) -> Gt;
        fn gte(_: String) -> Gte;
        fn contains(_: String) -> Contains;
        fn starts_with(_: String) -> StartsWith;
        fn ends_with(_: String) -> EndsWith;
        fn not(_: String) -> Not;
      }
    );
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::State(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::State(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod statuses {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "statuses";
    pub struct Fetch(pub status::ManyArgs);
    impl Fetch {
      pub fn with(mut self, params: impl Into<status::WithParam>) -> Self {
        self.0 = self.0.with(params.into());
        self
      }
      pub fn order_by(mut self, param: status::OrderByParam) -> Self {
        self.0 = self.0.order_by(param);
        self
      }
      pub fn skip(mut self, value: i64) -> Self {
        self.0 = self.0.skip(value);
        self
      }
      pub fn take(mut self, value: i64) -> Self {
        self.0 = self.0.take(value);
        self
      }
      pub fn cursor(mut self, value: status::UniqueWhereParam) -> Self {
        self.0 = self.0.cursor(value.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(Fetch(v): Fetch) -> Self {
        WithParam::Statuses(v)
      }
    }
    pub fn fetch(params: Vec<status::WhereParam>) -> Fetch {
      Fetch(status::ManyArgs::new(params))
    }
    pub struct Connect(pub Vec<status::UniqueWhereParam>);
    impl From<Connect> for SetParam {
      fn from(Connect(v): Connect) -> Self {
        Self::ConnectStatuses(v)
      }
    }
    pub fn connect<T: From<Connect>>(
      params: Vec<status::UniqueWhereParam>,
    ) -> T {
      Connect(params).into()
    }
    pub fn disconnect(params: Vec<status::UniqueWhereParam>) -> SetParam {
      SetParam::DisconnectStatuses(params)
    }
    pub fn set(params: Vec<status::UniqueWhereParam>) -> SetParam {
      SetParam::SetStatuses(params)
    }
    pub fn some(value: Vec<status::WhereParam>) -> WhereParam {
      WhereParam::StatusesSome(value)
    }
    pub fn every(value: Vec<status::WhereParam>) -> WhereParam {
      WhereParam::StatusesEvery(value)
    }
    pub fn none(value: Vec<status::WhereParam>) -> WhereParam {
      WhereParam::StatusesNone(value)
    }
    pub enum Include {
      Select(status::ManyArgs, Vec<status::SelectParam>),
      Include(status::ManyArgs, Vec<status::IncludeParam>),
      Fetch(status::ManyArgs),
    }
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Statuses(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < status :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < status :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
        ::prisma_client_rust::Selection::new(NAME, None, args, selections)
      }
      pub fn select(
        args: status::ManyArgs,
        nested_selections: Vec<status::SelectParam>,
      ) -> Self {
        Self::Select(args, nested_selections)
      }
      pub fn include(
        args: status::ManyArgs,
        nested_selections: Vec<status::IncludeParam>,
      ) -> Self {
        Self::Include(args, nested_selections)
      }
    }
    pub enum Select {
      Select(status::ManyArgs, Vec<status::SelectParam>),
      Include(status::ManyArgs, Vec<status::IncludeParam>),
      Fetch(status::ManyArgs),
    }
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Statuses(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < status :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
        ::prisma_client_rust::Selection::new(NAME, None, args, selections)
      }
      pub fn select(
        args: status::ManyArgs,
        nested_selections: Vec<status::SelectParam>,
      ) -> Self {
        Self::Select(args, nested_selections)
      }
      pub fn include(
        args: status::ManyArgs,
        nested_selections: Vec<status::IncludeParam>,
      ) -> Self {
        Self::Include(args, nested_selections)
      }
    }
  }
  pub mod branches {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "branches";
    pub struct Fetch(pub branch::ManyArgs);
    impl Fetch {
      pub fn with(mut self, params: impl Into<branch::WithParam>) -> Self {
        self.0 = self.0.with(params.into());
        self
      }
      pub fn order_by(mut self, param: branch::OrderByParam) -> Self {
        self.0 = self.0.order_by(param);
        self
      }
      pub fn skip(mut self, value: i64) -> Self {
        self.0 = self.0.skip(value);
        self
      }
      pub fn take(mut self, value: i64) -> Self {
        self.0 = self.0.take(value);
        self
      }
      pub fn cursor(mut self, value: branch::UniqueWhereParam) -> Self {
        self.0 = self.0.cursor(value.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(Fetch(v): Fetch) -> Self {
        WithParam::Branches(v)
      }
    }
    pub fn fetch(params: Vec<branch::WhereParam>) -> Fetch {
      Fetch(branch::ManyArgs::new(params))
    }
    pub struct Connect(pub Vec<branch::UniqueWhereParam>);
    impl From<Connect> for SetParam {
      fn from(Connect(v): Connect) -> Self {
        Self::ConnectBranches(v)
      }
    }
    pub fn connect<T: From<Connect>>(
      params: Vec<branch::UniqueWhereParam>,
    ) -> T {
      Connect(params).into()
    }
    pub fn disconnect(params: Vec<branch::UniqueWhereParam>) -> SetParam {
      SetParam::DisconnectBranches(params)
    }
    pub fn set(params: Vec<branch::UniqueWhereParam>) -> SetParam {
      SetParam::SetBranches(params)
    }
    pub fn some(value: Vec<branch::WhereParam>) -> WhereParam {
      WhereParam::BranchesSome(value)
    }
    pub fn every(value: Vec<branch::WhereParam>) -> WhereParam {
      WhereParam::BranchesEvery(value)
    }
    pub fn none(value: Vec<branch::WhereParam>) -> WhereParam {
      WhereParam::BranchesNone(value)
    }
    pub enum Include {
      Select(branch::ManyArgs, Vec<branch::SelectParam>),
      Include(branch::ManyArgs, Vec<branch::IncludeParam>),
      Fetch(branch::ManyArgs),
    }
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Branches(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < branch :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < branch :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
        ::prisma_client_rust::Selection::new(NAME, None, args, selections)
      }
      pub fn select(
        args: branch::ManyArgs,
        nested_selections: Vec<branch::SelectParam>,
      ) -> Self {
        Self::Select(args, nested_selections)
      }
      pub fn include(
        args: branch::ManyArgs,
        nested_selections: Vec<branch::IncludeParam>,
      ) -> Self {
        Self::Include(args, nested_selections)
      }
    }
    pub enum Select {
      Select(branch::ManyArgs, Vec<branch::SelectParam>),
      Include(branch::ManyArgs, Vec<branch::IncludeParam>),
      Fetch(branch::ManyArgs),
    }
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Branches(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < branch :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
        ::prisma_client_rust::Selection::new(NAME, None, args, selections)
      }
      pub fn select(
        args: branch::ManyArgs,
        nested_selections: Vec<branch::SelectParam>,
      ) -> Self {
        Self::Select(args, nested_selections)
      }
      pub fn include(
        args: branch::ManyArgs,
        nested_selections: Vec<branch::IncludeParam>,
      ) -> Self {
        Self::Include(args, nested_selections)
      }
    }
  }
  pub fn create(
    dir: String,
    managed: bool,
    name: String,
    is_valid: bool,
    state: String,
    _params: Vec<SetParam>,
  ) -> (String, bool, String, bool, String, Vec<SetParam>) {
    (dir, managed, name, is_valid, state, _params)
  }
  pub fn create_unchecked(
    dir: String,
    managed: bool,
    name: String,
    is_valid: bool,
    state: String,
    _params: Vec<SetParam>,
  ) -> (String, bool, String, bool, String, Vec<SetParam>) {
    (dir, managed, name, is_valid, state, _params)
  }
  #[macro_export]
  macro_rules ! _select_repo { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: repo :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: repo :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: repo :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: repo :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: repo :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: repo :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { dir , managed , updated_at , name , is_valid , state , statuses , branches } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: repo :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: repo :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: repo :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: repo :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: repo :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: repo :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["dir" , "managed" , "updatedAt" , "name" , "is_valid" , "state" , "statuses" , "branches"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: repo :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; dir) => { String } ; (@ field_type ; managed) => { bool } ; (@ field_type ; updated_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; name) => { String } ; (@ field_type ; is_valid) => { bool } ; (@ field_type ; state) => { String } ; (@ field_type ; statuses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < statuses :: Data > } ; (@ field_type ; statuses) => { Vec < crate :: prisma :: status :: Data > } ; (@ field_type ; branches : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < branches :: Data > } ; (@ field_type ; branches) => { Vec < crate :: prisma :: branch :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Repo" , available relations are "dir, managed, updated_at, name, is_valid, state, statuses, branches")) } ; (@ field_module ; statuses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: status :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; branches : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: branch :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; dir) => { Into :: < crate :: prisma :: repo :: SelectParam > :: into (crate :: prisma :: repo :: dir :: Select) } ; (@ selection_field_to_selection_param ; managed) => { Into :: < crate :: prisma :: repo :: SelectParam > :: into (crate :: prisma :: repo :: managed :: Select) } ; (@ selection_field_to_selection_param ; updated_at) => { Into :: < crate :: prisma :: repo :: SelectParam > :: into (crate :: prisma :: repo :: updated_at :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: repo :: SelectParam > :: into (crate :: prisma :: repo :: name :: Select) } ; (@ selection_field_to_selection_param ; is_valid) => { Into :: < crate :: prisma :: repo :: SelectParam > :: into (crate :: prisma :: repo :: is_valid :: Select) } ; (@ selection_field_to_selection_param ; state) => { Into :: < crate :: prisma :: repo :: SelectParam > :: into (crate :: prisma :: repo :: state :: Select) } ; (@ selection_field_to_selection_param ; statuses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: repo :: SelectParam > :: into (crate :: prisma :: repo :: statuses :: Select :: $ selection_mode (crate :: prisma :: status :: ManyArgs :: new (crate :: prisma :: status :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: status :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; statuses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: repo :: SelectParam > :: into (crate :: prisma :: repo :: statuses :: Select :: Fetch (crate :: prisma :: status :: ManyArgs :: new (crate :: prisma :: status :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; branches $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: repo :: SelectParam > :: into (crate :: prisma :: repo :: branches :: Select :: $ selection_mode (crate :: prisma :: branch :: ManyArgs :: new (crate :: prisma :: branch :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: branch :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; branches $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: repo :: SelectParam > :: into (crate :: prisma :: repo :: branches :: Select :: Fetch (crate :: prisma :: branch :: ManyArgs :: new (crate :: prisma :: branch :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: repo :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; dir) => { "dir" } ; (@ field_serde_name ; managed) => { "managed" } ; (@ field_serde_name ; updated_at) => { "updatedAt" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; is_valid) => { "is_valid" } ; (@ field_serde_name ; state) => { "state" } ; (@ field_serde_name ; statuses) => { "statuses" } ; (@ field_serde_name ; branches) => { "branches" } ; }
  pub use _select_repo as select;
  pub enum SelectParam {
    Dir(dir::Select),
    Managed(managed::Select),
    UpdatedAt(updated_at::Select),
    Name(name::Select),
    IsValid(is_valid::Select),
    State(state::Select),
    Statuses(statuses::Select),
    Branches(branches::Select),
  }
  impl SelectParam {
    pub fn to_selection(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Dir(data) => data.to_selection(),
        Self::Managed(data) => data.to_selection(),
        Self::UpdatedAt(data) => data.to_selection(),
        Self::Name(data) => data.to_selection(),
        Self::IsValid(data) => data.to_selection(),
        Self::State(data) => data.to_selection(),
        Self::Statuses(data) => data.to_selection(),
        Self::Branches(data) => data.to_selection(),
      }
    }
  }
  #[macro_export]
  macro_rules ! _include_repo { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: repo :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: repo :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: repo :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: repo :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: repo :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: repo :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: repo :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: repo :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { statuses , branches } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub dir : String , pub managed : bool , pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub name : String , pub is_valid : bool , pub state : String , $ (pub $ field : crate :: prisma :: repo :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (dir) , stringify ! (managed) , stringify ! (updated_at) , stringify ! (name) , stringify ! (is_valid) , stringify ! (state)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: repo :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: repo :: dir :: NAME , & self . dir) ? ; state . serialize_field (crate :: prisma :: repo :: managed :: NAME , & self . managed) ? ; state . serialize_field (crate :: prisma :: repo :: updated_at :: NAME , & self . updated_at) ? ; state . serialize_field (crate :: prisma :: repo :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: repo :: is_valid :: NAME , & self . is_valid) ? ; state . serialize_field (crate :: prisma :: repo :: state :: NAME , & self . state) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , dir , managed , updated_at , name , is_valid , state } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: repo :: $ field :: NAME) , + , crate :: prisma :: repo :: dir :: NAME , crate :: prisma :: repo :: managed :: NAME , crate :: prisma :: repo :: updated_at :: NAME , crate :: prisma :: repo :: name :: NAME , crate :: prisma :: repo :: is_valid :: NAME , crate :: prisma :: repo :: state :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: repo :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: repo :: dir :: NAME => Ok (Field :: dir) , crate :: prisma :: repo :: managed :: NAME => Ok (Field :: managed) , crate :: prisma :: repo :: updated_at :: NAME => Ok (Field :: updated_at) , crate :: prisma :: repo :: name :: NAME => Ok (Field :: name) , crate :: prisma :: repo :: is_valid :: NAME => Ok (Field :: is_valid) , crate :: prisma :: repo :: state :: NAME => Ok (Field :: state) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut dir = None ; let mut managed = None ; let mut updated_at = None ; let mut name = None ; let mut is_valid = None ; let mut state = None ; while let Some (key) = map . next_key () ? { match key { Field :: dir => { if dir . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: repo :: dir :: NAME)) ; } dir = Some (map . next_value () ?) ; } Field :: managed => { if managed . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: repo :: managed :: NAME)) ; } managed = Some (map . next_value () ?) ; } Field :: updated_at => { if updated_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: repo :: updated_at :: NAME)) ; } updated_at = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: repo :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: is_valid => { if is_valid . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: repo :: is_valid :: NAME)) ; } is_valid = Some (map . next_value () ?) ; } Field :: state => { if state . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: repo :: state :: NAME)) ; } state = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: repo :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: repo :: $ field :: NAME)) ? ;) * let dir = dir . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: repo :: dir :: NAME)) ? ; let managed = managed . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: repo :: managed :: NAME)) ? ; let updated_at = updated_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: repo :: updated_at :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: repo :: name :: NAME)) ? ; let is_valid = is_valid . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: repo :: is_valid :: NAME)) ? ; let state = state . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: repo :: state :: NAME)) ? ; Ok (Data { dir , managed , updated_at , name , is_valid , state , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["dir" , "managed" , "updatedAt" , "name" , "is_valid" , "state" , "statuses" , "branches"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: repo :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; statuses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < statuses :: Data > } ; (@ field_type ; statuses) => { Vec < crate :: prisma :: status :: Data > } ; (@ field_type ; branches : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < branches :: Data > } ; (@ field_type ; branches) => { Vec < crate :: prisma :: branch :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Repo" , available relations are "statuses, branches")) } ; (@ field_module ; statuses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: status :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; branches : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: branch :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; statuses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: repo :: IncludeParam > :: into (crate :: prisma :: repo :: statuses :: Include :: $ selection_mode (crate :: prisma :: status :: ManyArgs :: new (crate :: prisma :: status :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: status :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; statuses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: repo :: IncludeParam > :: into (crate :: prisma :: repo :: statuses :: Include :: Fetch (crate :: prisma :: status :: ManyArgs :: new (crate :: prisma :: status :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; branches $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: repo :: IncludeParam > :: into (crate :: prisma :: repo :: branches :: Include :: $ selection_mode (crate :: prisma :: branch :: ManyArgs :: new (crate :: prisma :: branch :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: branch :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; branches $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: repo :: IncludeParam > :: into (crate :: prisma :: repo :: branches :: Include :: Fetch (crate :: prisma :: branch :: ManyArgs :: new (crate :: prisma :: branch :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: repo :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; dir) => { "dir" } ; (@ field_serde_name ; managed) => { "managed" } ; (@ field_serde_name ; updated_at) => { "updatedAt" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; is_valid) => { "is_valid" } ; (@ field_serde_name ; state) => { "state" } ; (@ field_serde_name ; statuses) => { "statuses" } ; (@ field_serde_name ; branches) => { "branches" } ; }
  pub use _include_repo as include;
  pub enum IncludeParam {
    Dir(dir::Include),
    Managed(managed::Include),
    UpdatedAt(updated_at::Include),
    Name(name::Include),
    IsValid(is_valid::Include),
    State(state::Include),
    Statuses(statuses::Include),
    Branches(branches::Include),
  }
  impl IncludeParam {
    pub fn to_selection(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Dir(data) => data.to_selection(),
        Self::Managed(data) => data.to_selection(),
        Self::UpdatedAt(data) => data.to_selection(),
        Self::Name(data) => data.to_selection(),
        Self::IsValid(data) => data.to_selection(),
        Self::State(data) => data.to_selection(),
        Self::Statuses(data) => data.to_selection(),
        Self::Branches(data) => data.to_selection(),
      }
    }
  }
  #[macro_export]
  macro_rules ! _partial_unchecked_repo { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: repo struct $ struct_name { # [serde (rename = "dir")] pub dir : String , # [serde (rename = "managed")] pub managed : bool , # [serde (rename = "updatedAt")] pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "name")] pub name : String , # [serde (rename = "is_valid")] pub is_valid : bool , # [serde (rename = "state")] pub state : String } [$ ($ scalar_field) , +] } } ; }
  pub use _partial_unchecked_repo as partial_unchecked;
  #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
  pub struct Data {
    #[serde(rename = "dir")]
    pub dir: String,
    #[serde(rename = "managed")]
    pub managed: bool,
    #[serde(rename = "updatedAt")]
    pub updated_at: ::prisma_client_rust::chrono::DateTime<
      ::prisma_client_rust::chrono::FixedOffset,
    >,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "is_valid")]
    pub is_valid: bool,
    #[serde(rename = "state")]
    pub state: String,
    #[serde(rename = "statuses")]
    pub statuses: Option<Vec<super::status::Data>>,
    #[serde(rename = "branches")]
    pub branches: Option<Vec<super::branch::Data>>,
  }
  impl Data {
    pub fn statuses(
      &self,
    ) -> Result<
      &Vec<super::status::Data>,
      ::prisma_client_rust::RelationNotFetchedError,
    > {
      self.statuses.as_ref().ok_or(
        ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
          statuses
        )),
      )
    }
    pub fn branches(
      &self,
    ) -> Result<
      &Vec<super::branch::Data>,
      ::prisma_client_rust::RelationNotFetchedError,
    > {
      self.branches.as_ref().ok_or(
        ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
          branches
        )),
      )
    }
  }
  #[derive(Clone)]
  pub enum WithParam {
    Statuses(super::status::ManyArgs),
    Branches(super::branch::ManyArgs),
  }
  impl Into<::prisma_client_rust::Selection> for WithParam {
    fn into(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Statuses(args) => {
          let (arguments, mut nested_selections) = args.to_graphql();
          nested_selections . extend (< super :: status :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
          ::prisma_client_rust::Selection::new(
            statuses::NAME,
            None,
            arguments,
            nested_selections,
          )
        }
        Self::Branches(args) => {
          let (arguments, mut nested_selections) = args.to_graphql();
          nested_selections . extend (< super :: branch :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
          ::prisma_client_rust::Selection::new(
            branches::NAME,
            None,
            arguments,
            nested_selections,
          )
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum SetParam {
    SetDir(String),
    SetManaged(bool),
    SetUpdatedAt(
      ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset,
      >,
    ),
    SetName(String),
    SetIsValid(bool),
    SetState(String),
    ConnectStatuses(Vec<super::status::UniqueWhereParam>),
    DisconnectStatuses(Vec<super::status::UniqueWhereParam>),
    SetStatuses(Vec<super::status::UniqueWhereParam>),
    ConnectBranches(Vec<super::branch::UniqueWhereParam>),
    DisconnectBranches(Vec<super::branch::UniqueWhereParam>),
    SetBranches(Vec<super::branch::UniqueWhereParam>),
  }
  impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
    fn from(param: SetParam) -> Self {
      match param {
        SetParam::SetDir(value) => (
          dir::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(value),
        ),
        SetParam::SetManaged(value) => (
          managed::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Boolean(value),
        ),
        SetParam::SetUpdatedAt(value) => (
          updated_at::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::DateTime(value),
        ),
        SetParam::SetName(value) => (
          name::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(value),
        ),
        SetParam::SetIsValid(value) => (
          is_valid::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Boolean(value),
        ),
        SetParam::SetState(value) => (
          state::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(value),
        ),
        SetParam::ConnectStatuses(where_params) => (
          statuses::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "connect".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              where_params
                .into_iter()
                .map(Into::<super::status::WhereParam>::into)
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                .collect(),
            ),
          )]),
        ),
        SetParam::DisconnectStatuses(where_params) => (
          statuses::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "disconnect".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              where_params
                .into_iter()
                .map(Into::<super::status::WhereParam>::into)
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                .collect(),
            ),
          )]),
        ),
        SetParam::SetStatuses(where_params) => (
          statuses::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "set".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              where_params
                .into_iter()
                .map(Into::<super::status::WhereParam>::into)
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                .collect(),
            ),
          )]),
        ),
        SetParam::ConnectBranches(where_params) => (
          branches::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "connect".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              where_params
                .into_iter()
                .map(Into::<super::branch::WhereParam>::into)
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                .collect(),
            ),
          )]),
        ),
        SetParam::DisconnectBranches(where_params) => (
          branches::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "disconnect".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              where_params
                .into_iter()
                .map(Into::<super::branch::WhereParam>::into)
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                .collect(),
            ),
          )]),
        ),
        SetParam::SetBranches(where_params) => (
          branches::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "set".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              where_params
                .into_iter()
                .map(Into::<super::branch::WhereParam>::into)
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                .collect(),
            ),
          )]),
        ),
      }
    }
  }
  #[derive(Clone)]
  pub enum UncheckedSetParam {
    Dir(String),
    Managed(bool),
    UpdatedAt(
      ::prisma_client_rust::chrono::DateTime<
        ::prisma_client_rust::chrono::FixedOffset,
      >,
    ),
    Name(String),
    IsValid(bool),
    State(String),
  }
  impl From<UncheckedSetParam> for SetParam {
    fn from(param: UncheckedSetParam) -> Self {
      match param {
        UncheckedSetParam::Dir(value) => Self::SetDir(value),
        UncheckedSetParam::Managed(value) => Self::SetManaged(value),
        UncheckedSetParam::UpdatedAt(value) => Self::SetUpdatedAt(value),
        UncheckedSetParam::Name(value) => Self::SetName(value),
        UncheckedSetParam::IsValid(value) => Self::SetIsValid(value),
        UncheckedSetParam::State(value) => Self::SetState(value),
      }
    }
  }
  #[derive(Clone)]
  pub enum OrderByParam {
    Dir(::prisma_client_rust::Direction),
    Managed(::prisma_client_rust::Direction),
    UpdatedAt(::prisma_client_rust::Direction),
    Name(::prisma_client_rust::Direction),
    IsValid(::prisma_client_rust::Direction),
    State(::prisma_client_rust::Direction),
  }
  impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
    fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
      match self {
        Self::Dir(direction) => (
          dir::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::Managed(direction) => (
          managed::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::UpdatedAt(direction) => (
          updated_at::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::Name(direction) => (
          name::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::IsValid(direction) => (
          is_valid::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::State(direction) => (
          state::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
      }
    }
  }
  #[derive(Clone)]
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    Dir(_prisma::read_filters::StringFilter),
    Managed(_prisma::read_filters::BoolFilter),
    UpdatedAt(_prisma::read_filters::DateTimeFilter),
    Name(_prisma::read_filters::StringFilter),
    IsValid(_prisma::read_filters::BoolFilter),
    State(_prisma::read_filters::StringFilter),
    StatusesSome(Vec<super::status::WhereParam>),
    StatusesEvery(Vec<super::status::WhereParam>),
    StatusesNone(Vec<super::status::WhereParam>),
    BranchesSome(Vec<super::branch::WhereParam>),
    BranchesEvery(Vec<super::branch::WhereParam>),
    BranchesNone(Vec<super::branch::WhereParam>),
  }
  impl ::prisma_client_rust::WhereInput for WhereParam {
    fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
      let (name, value) = match self {
        Self::Not(value) => (
          "NOT",
          ::prisma_client_rust::SerializedWhereValue::Object(
            ::prisma_client_rust::merge_fields(
              value
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(Into::into)
                .collect(),
            ),
          ),
        ),
        Self::Or(value) => (
          "OR",
          ::prisma_client_rust::SerializedWhereValue::List(
            value
              .into_iter()
              .map(::prisma_client_rust::WhereInput::serialize)
              .map(Into::into)
              .map(|v| vec![v])
              .map(::prisma_client_rust::PrismaValue::Object)
              .collect(),
          ),
        ),
        Self::And(value) => (
          "AND",
          ::prisma_client_rust::SerializedWhereValue::Object(
            ::prisma_client_rust::merge_fields(
              value
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(Into::into)
                .collect(),
            ),
          ),
        ),
        Self::Dir(value) => (dir::NAME, value.into()),
        Self::Managed(value) => (managed::NAME, value.into()),
        Self::UpdatedAt(value) => (updated_at::NAME, value.into()),
        Self::Name(value) => (name::NAME, value.into()),
        Self::IsValid(value) => (is_valid::NAME, value.into()),
        Self::State(value) => (state::NAME, value.into()),
        Self::StatusesSome(where_params) => (
          statuses::NAME,
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "some".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
        Self::StatusesEvery(where_params) => (
          statuses::NAME,
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "every".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
        Self::StatusesNone(where_params) => (
          statuses::NAME,
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "none".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
        Self::BranchesSome(where_params) => (
          branches::NAME,
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "some".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
        Self::BranchesEvery(where_params) => (
          branches::NAME,
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "every".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
        Self::BranchesNone(where_params) => (
          branches::NAME,
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "none".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
      };
      ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
    }
  }
  #[derive(Clone)]
  pub enum UniqueWhereParam {
    DirEquals(String),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::DirEquals(value) => {
          Self::Dir(_prisma::read_filters::StringFilter::Equals(value))
        }
      }
    }
  }
  impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
    fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
      match op {
        ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
        ::prisma_client_rust::Operator::And(value) => Self::And(value),
        ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
      }
    }
  }
  #[derive(Clone)]
  pub struct Types;
  impl ::prisma_client_rust::ModelTypes for Types {
    type Data = Data;
    type Where = WhereParam;
    type UncheckedSet = UncheckedSetParam;
    type Set = SetParam;
    type With = WithParam;
    type OrderBy = OrderByParam;
    type Cursor = UniqueWhereParam;
    const MODEL: &'static str = NAME;
    fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
      vec![
        ::prisma_client_rust::sel(dir::NAME),
        ::prisma_client_rust::sel(managed::NAME),
        ::prisma_client_rust::sel(updated_at::NAME),
        ::prisma_client_rust::sel(name::NAME),
        ::prisma_client_rust::sel(is_valid::NAME),
        ::prisma_client_rust::sel(state::NAME),
      ]
    }
  }
  pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
  pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
  pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
  pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
  pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
  pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
  pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
  pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
  pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
  pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
  pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
  pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
  pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
  #[derive(Clone)]
  pub struct Actions<'a> {
    pub client: &'a ::prisma_client_rust::PrismaClientInternals,
  }
  impl<'a> Actions<'a> {
    pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
      FindUnique::new(self.client, _where.into())
    }
    pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
      FindFirst::new(self.client, _where)
    }
    pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
      FindMany::new(self.client, _where)
    }
    pub fn create(
      self,
      dir: String,
      managed: bool,
      name: String,
      is_valid: bool,
      state: String,
      mut _params: Vec<SetParam>,
    ) -> Create<'a> {
      _params.extend([
        dir::set(dir),
        managed::set(managed),
        name::set(name),
        is_valid::set(is_valid),
        state::set(state),
      ]);
      Create::new(self.client, _params)
    }
    pub fn create_unchecked(
      self,
      dir: String,
      managed: bool,
      name: String,
      is_valid: bool,
      state: String,
      mut _params: Vec<UncheckedSetParam>,
    ) -> Create<'a> {
      _params.extend([
        dir::set(dir),
        managed::set(managed),
        name::set(name),
        is_valid::set(is_valid),
        state::set(state),
      ]);
      Create::new(self.client, _params.into_iter().map(Into::into).collect())
    }
    pub fn update(
      self,
      _where: UniqueWhereParam,
      _params: Vec<SetParam>,
    ) -> Update<'a> {
      Update::new(self.client, _where.into(), _params, vec![])
    }
    pub fn update_unchecked(
      self,
      _where: UniqueWhereParam,
      _params: Vec<UncheckedSetParam>,
    ) -> Update<'a> {
      Update::new(
        self.client,
        _where.into(),
        _params.into_iter().map(Into::into).collect(),
        vec![],
      )
    }
    pub fn update_many(
      self,
      _where: Vec<WhereParam>,
      _params: Vec<SetParam>,
    ) -> UpdateMany<'a> {
      UpdateMany::new(self.client, _where, _params)
    }
    pub fn upsert(
      self,
      _where: UniqueWhereParam,
      (dir, managed, name, is_valid, state, mut _params): (
        String,
        bool,
        String,
        bool,
        String,
        Vec<SetParam>,
      ),
      _update: Vec<SetParam>,
    ) -> Upsert<'a> {
      _params.extend([
        dir::set(dir),
        managed::set(managed),
        name::set(name),
        is_valid::set(is_valid),
        state::set(state),
      ]);
      Upsert::new(self.client, _where.into(), _params, _update)
    }
    pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
      Delete::new(self.client, _where.into(), vec![])
    }
    pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
      DeleteMany::new(self.client, _where)
    }
    pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
      Count::new(self.client, _where)
    }
  }
}
pub mod status {
  use super::_prisma::*;
  use super::*;
  pub const NAME: &str = "Status";
  pub mod id {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "id";
    pub struct Set(pub i32);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetId(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::Id(v)
      }
    }
    pub fn set<T: From<Set>>(value: i32) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Id(direction)
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
      UniqueWhereParam::IdEquals(value).into()
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::IntFilter,
      Id,
      {
        fn in_vec(_: Vec<i32>) -> InVec;
        fn not_in_vec(_: Vec<i32>) -> NotInVec;
        fn lt(_: i32) -> Lt;
        fn lte(_: i32) -> Lte;
        fn gt(_: i32) -> Gt;
        fn gte(_: i32) -> Gte;
        fn not(_: i32) -> Not;
      }
    );
    pub fn increment(value: i32) -> SetParam {
      SetParam::IncrementId(value)
    }
    pub fn decrement(value: i32) -> SetParam {
      SetParam::DecrementId(value)
    }
    pub fn multiply(value: i32) -> SetParam {
      SetParam::MultiplyId(value)
    }
    pub fn divide(value: i32) -> SetParam {
      SetParam::DivideId(value)
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Id(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Id(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod status {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "status";
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetStatus(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::Status(v)
      }
    }
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Status(direction)
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::Status(_prisma::read_filters::StringFilter::Equals(value))
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::StringFilter,
      Status,
      {
        fn in_vec(_: Vec<String>) -> InVec;
        fn not_in_vec(_: Vec<String>) -> NotInVec;
        fn lt(_: String) -> Lt;
        fn lte(_: String) -> Lte;
        fn gt(_: String) -> Gt;
        fn gte(_: String) -> Gte;
        fn contains(_: String) -> Contains;
        fn starts_with(_: String) -> StartsWith;
        fn ends_with(_: String) -> EndsWith;
        fn not(_: String) -> Not;
      }
    );
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Status(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Status(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod path {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "path";
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetPath(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::Path(v)
      }
    }
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Path(direction)
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::Equals(value))
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::StringFilter,
      Path,
      {
        fn in_vec(_: Vec<String>) -> InVec;
        fn not_in_vec(_: Vec<String>) -> NotInVec;
        fn lt(_: String) -> Lt;
        fn lte(_: String) -> Lte;
        fn gt(_: String) -> Gt;
        fn gte(_: String) -> Gte;
        fn contains(_: String) -> Contains;
        fn starts_with(_: String) -> StartsWith;
        fn ends_with(_: String) -> EndsWith;
        fn not(_: String) -> Not;
      }
    );
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Path(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Path(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod repo {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "Repo";
    pub struct Fetch(pub repo::UniqueArgs);
    impl Fetch {
      pub fn with(mut self, params: impl Into<repo::WithParam>) -> Self {
        self.0 = self.0.with(params.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(Fetch(v): Fetch) -> Self {
        WithParam::Repo(v)
      }
    }
    pub fn fetch() -> Fetch {
      Fetch(repo::UniqueArgs::new())
    }
    pub struct Connect(repo::UniqueWhereParam);
    impl From<Connect> for SetParam {
      fn from(Connect(v): Connect) -> Self {
        Self::ConnectRepo(v)
      }
    }
    pub fn connect<T: From<Connect>>(value: repo::UniqueWhereParam) -> T {
      Connect(value).into()
    }
    pub fn is(value: Vec<repo::WhereParam>) -> WhereParam {
      WhereParam::RepoIs(value)
    }
    pub fn is_not(value: Vec<repo::WhereParam>) -> WhereParam {
      WhereParam::RepoIsNot(value)
    }
    pub enum Include {
      Select(Vec<repo::SelectParam>),
      Include(Vec<repo::IncludeParam>),
      Fetch,
    }
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Repo(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        let selections = match self {
          Self::Select(selections) => {
            selections.into_iter().map(|s| s.to_selection()).collect()
          }
          Self::Include(selections) => {
            let mut nested_selections = < repo :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
            nested_selections
              .extend(selections.into_iter().map(|s| s.to_selection()));
            nested_selections
          }
          Self::Fetch => {
            <repo::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
            )
          }
        };
        ::prisma_client_rust::Selection::new("Repo", None, [], selections)
      }
      pub fn select(nested_selections: Vec<repo::SelectParam>) -> Self {
        Self::Select(nested_selections)
      }
      pub fn include(nested_selections: Vec<repo::IncludeParam>) -> Self {
        Self::Include(nested_selections)
      }
    }
    pub enum Select {
      Select(Vec<repo::SelectParam>),
      Include(Vec<repo::IncludeParam>),
      Fetch,
    }
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Repo(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        let selections = match self {
          Self::Select(selections) => {
            selections.into_iter().map(|s| s.to_selection()).collect()
          }
          Self::Include(selections) => {
            let mut nested_selections = vec![];
            nested_selections
              .extend(selections.into_iter().map(|s| s.to_selection()));
            nested_selections
          }
          Self::Fetch => {
            <repo::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
            )
          }
        };
        ::prisma_client_rust::Selection::new("Repo", None, [], selections)
      }
      pub fn select(nested_selections: Vec<repo::SelectParam>) -> Self {
        Self::Select(nested_selections)
      }
      pub fn include(nested_selections: Vec<repo::IncludeParam>) -> Self {
        Self::Include(nested_selections)
      }
    }
  }
  pub mod repo_dir {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "repoDir";
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetRepoDir(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::RepoDir(v)
      }
    }
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::RepoDir(direction)
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::RepoDir(_prisma::read_filters::StringFilter::Equals(value))
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::StringFilter,
      RepoDir,
      {
        fn in_vec(_: Vec<String>) -> InVec;
        fn not_in_vec(_: Vec<String>) -> NotInVec;
        fn lt(_: String) -> Lt;
        fn lte(_: String) -> Lte;
        fn gt(_: String) -> Gt;
        fn gte(_: String) -> Gte;
        fn contains(_: String) -> Contains;
        fn starts_with(_: String) -> StartsWith;
        fn ends_with(_: String) -> EndsWith;
        fn not(_: String) -> Not;
      }
    );
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::RepoDir(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::RepoDir(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub fn create(
    status: String,
    path: String,
    repo: super::repo::UniqueWhereParam,
    _params: Vec<SetParam>,
  ) -> (String, String, super::repo::UniqueWhereParam, Vec<SetParam>) {
    (status, path, repo, _params)
  }
  pub fn create_unchecked(
    status: String,
    path: String,
    repo_dir: String,
    _params: Vec<SetParam>,
  ) -> (String, String, String, Vec<SetParam>) {
    (status, path, repo_dir, _params)
  }
  #[macro_export]
  macro_rules ! _select_status { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: status :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: status :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: status :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: status :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: status :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: status :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , status , path , repo , repo_dir } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: status :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: status :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: status :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: status :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: status :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: status :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "status" , "path" , "Repo" , "repoDir"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: status :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; status) => { String } ; (@ field_type ; path) => { String } ; (@ field_type ; repo : $ selection_mode : ident { $ ($ selections : tt) + }) => { repo :: Data } ; (@ field_type ; repo) => { crate :: prisma :: repo :: Data } ; (@ field_type ; repo_dir) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Status" , available relations are "id, status, path, repo, repo_dir")) } ; (@ field_module ; repo : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: repo :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: status :: SelectParam > :: into (crate :: prisma :: status :: id :: Select) } ; (@ selection_field_to_selection_param ; status) => { Into :: < crate :: prisma :: status :: SelectParam > :: into (crate :: prisma :: status :: status :: Select) } ; (@ selection_field_to_selection_param ; path) => { Into :: < crate :: prisma :: status :: SelectParam > :: into (crate :: prisma :: status :: path :: Select) } ; (@ selection_field_to_selection_param ; repo $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: status :: SelectParam > :: into (crate :: prisma :: status :: repo :: Select :: $ selection_mode (crate :: prisma :: repo :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; repo $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: status :: SelectParam > :: into (crate :: prisma :: status :: repo :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; repo_dir) => { Into :: < crate :: prisma :: status :: SelectParam > :: into (crate :: prisma :: status :: repo_dir :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: status :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; status) => { "status" } ; (@ field_serde_name ; path) => { "path" } ; (@ field_serde_name ; repo) => { "Repo" } ; (@ field_serde_name ; repo_dir) => { "repoDir" } ; }
  pub use _select_status as select;
  pub enum SelectParam {
    Id(id::Select),
    Status(status::Select),
    Path(path::Select),
    Repo(repo::Select),
    RepoDir(repo_dir::Select),
  }
  impl SelectParam {
    pub fn to_selection(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Id(data) => data.to_selection(),
        Self::Status(data) => data.to_selection(),
        Self::Path(data) => data.to_selection(),
        Self::Repo(data) => data.to_selection(),
        Self::RepoDir(data) => data.to_selection(),
      }
    }
  }
  #[macro_export]
  macro_rules ! _include_status { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: status :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: status :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: status :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: status :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: status :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: status :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: status :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: status :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { repo } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub status : String , pub path : String , pub repo_dir : String , $ (pub $ field : crate :: prisma :: status :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (status) , stringify ! (path) , stringify ! (repo_dir)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: status :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: status :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: status :: status :: NAME , & self . status) ? ; state . serialize_field (crate :: prisma :: status :: path :: NAME , & self . path) ? ; state . serialize_field (crate :: prisma :: status :: repo_dir :: NAME , & self . repo_dir) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , status , path , repo_dir } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: status :: $ field :: NAME) , + , crate :: prisma :: status :: id :: NAME , crate :: prisma :: status :: status :: NAME , crate :: prisma :: status :: path :: NAME , crate :: prisma :: status :: repo_dir :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: status :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: status :: id :: NAME => Ok (Field :: id) , crate :: prisma :: status :: status :: NAME => Ok (Field :: status) , crate :: prisma :: status :: path :: NAME => Ok (Field :: path) , crate :: prisma :: status :: repo_dir :: NAME => Ok (Field :: repo_dir) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut status = None ; let mut path = None ; let mut repo_dir = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: status :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: status => { if status . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: status :: status :: NAME)) ; } status = Some (map . next_value () ?) ; } Field :: path => { if path . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: status :: path :: NAME)) ; } path = Some (map . next_value () ?) ; } Field :: repo_dir => { if repo_dir . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: status :: repo_dir :: NAME)) ; } repo_dir = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: status :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: status :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: status :: id :: NAME)) ? ; let status = status . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: status :: status :: NAME)) ? ; let path = path . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: status :: path :: NAME)) ? ; let repo_dir = repo_dir . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: status :: repo_dir :: NAME)) ? ; Ok (Data { id , status , path , repo_dir , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "status" , "path" , "Repo" , "repoDir"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: status :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; repo : $ selection_mode : ident { $ ($ selections : tt) + }) => { repo :: Data } ; (@ field_type ; repo) => { crate :: prisma :: repo :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Status" , available relations are "repo")) } ; (@ field_module ; repo : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: repo :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; repo $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: status :: IncludeParam > :: into (crate :: prisma :: status :: repo :: Include :: $ selection_mode (crate :: prisma :: repo :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; repo $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: status :: IncludeParam > :: into (crate :: prisma :: status :: repo :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: status :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; status) => { "status" } ; (@ field_serde_name ; path) => { "path" } ; (@ field_serde_name ; repo) => { "Repo" } ; (@ field_serde_name ; repo_dir) => { "repoDir" } ; }
  pub use _include_status as include;
  pub enum IncludeParam {
    Id(id::Include),
    Status(status::Include),
    Path(path::Include),
    Repo(repo::Include),
    RepoDir(repo_dir::Include),
  }
  impl IncludeParam {
    pub fn to_selection(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Id(data) => data.to_selection(),
        Self::Status(data) => data.to_selection(),
        Self::Path(data) => data.to_selection(),
        Self::Repo(data) => data.to_selection(),
        Self::RepoDir(data) => data.to_selection(),
      }
    }
  }
  #[macro_export]
  macro_rules ! _partial_unchecked_status { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: status struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "status")] pub status : String , # [serde (rename = "path")] pub path : String , # [serde (rename = "repoDir")] pub repo_dir : String } [$ ($ scalar_field) , +] } } ; }
  pub use _partial_unchecked_status as partial_unchecked;
  #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
  pub struct Data {
    #[serde(rename = "id")]
    pub id: i32,
    #[serde(rename = "status")]
    pub status: String,
    #[serde(rename = "path")]
    pub path: String,
    #[serde(rename = "Repo")]
    pub repo: Option<Box<super::repo::Data>>,
    #[serde(rename = "repoDir")]
    pub repo_dir: String,
  }
  impl Data {
    pub fn repo(
      &self,
    ) -> Result<&super::repo::Data, ::prisma_client_rust::RelationNotFetchedError>
    {
      self
        .repo
        .as_ref()
        .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
          stringify!(repo),
        ))
        .map(|v| v.as_ref())
    }
  }
  #[derive(Clone)]
  pub enum WithParam {
    Repo(super::repo::UniqueArgs),
  }
  impl Into<::prisma_client_rust::Selection> for WithParam {
    fn into(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Repo(args) => {
          let mut selections = < super :: repo :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
          selections.extend(
            args
              .with_params
              .into_iter()
              .map(Into::<::prisma_client_rust::Selection>::into),
          );
          ::prisma_client_rust::Selection::new(repo::NAME, None, [], selections)
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum SetParam {
    SetId(i32),
    IncrementId(i32),
    DecrementId(i32),
    MultiplyId(i32),
    DivideId(i32),
    SetStatus(String),
    SetPath(String),
    ConnectRepo(super::repo::UniqueWhereParam),
    SetRepoDir(String),
  }
  impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
    fn from(param: SetParam) -> Self {
      match param {
        SetParam::SetId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Int(value as i64),
        ),
        SetParam::IncrementId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "increment".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::DecrementId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "decrement".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::MultiplyId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "multiply".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::DivideId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "divide".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::SetStatus(value) => (
          status::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(value),
        ),
        SetParam::SetPath(value) => (
          path::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(value),
        ),
        SetParam::ConnectRepo(where_param) => (
          repo::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "connect".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              [where_param]
                .into_iter()
                .map(Into::<super::repo::WhereParam>::into)
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
        SetParam::SetRepoDir(value) => (
          repo_dir::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(value),
        ),
      }
    }
  }
  #[derive(Clone)]
  pub enum UncheckedSetParam {
    Id(i32),
    Status(String),
    Path(String),
    RepoDir(String),
  }
  impl From<UncheckedSetParam> for SetParam {
    fn from(param: UncheckedSetParam) -> Self {
      match param {
        UncheckedSetParam::Id(value) => Self::SetId(value),
        UncheckedSetParam::Status(value) => Self::SetStatus(value),
        UncheckedSetParam::Path(value) => Self::SetPath(value),
        UncheckedSetParam::RepoDir(value) => Self::SetRepoDir(value),
      }
    }
  }
  #[derive(Clone)]
  pub enum OrderByParam {
    Id(::prisma_client_rust::Direction),
    Status(::prisma_client_rust::Direction),
    Path(::prisma_client_rust::Direction),
    RepoDir(::prisma_client_rust::Direction),
  }
  impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
    fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
      match self {
        Self::Id(direction) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::Status(direction) => (
          status::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::Path(direction) => (
          path::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::RepoDir(direction) => (
          repo_dir::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
      }
    }
  }
  #[derive(Clone)]
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    Id(_prisma::read_filters::IntFilter),
    Status(_prisma::read_filters::StringFilter),
    Path(_prisma::read_filters::StringFilter),
    RepoIs(Vec<super::repo::WhereParam>),
    RepoIsNot(Vec<super::repo::WhereParam>),
    RepoDir(_prisma::read_filters::StringFilter),
  }
  impl ::prisma_client_rust::WhereInput for WhereParam {
    fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
      let (name, value) = match self {
        Self::Not(value) => (
          "NOT",
          ::prisma_client_rust::SerializedWhereValue::Object(
            ::prisma_client_rust::merge_fields(
              value
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(Into::into)
                .collect(),
            ),
          ),
        ),
        Self::Or(value) => (
          "OR",
          ::prisma_client_rust::SerializedWhereValue::List(
            value
              .into_iter()
              .map(::prisma_client_rust::WhereInput::serialize)
              .map(Into::into)
              .map(|v| vec![v])
              .map(::prisma_client_rust::PrismaValue::Object)
              .collect(),
          ),
        ),
        Self::And(value) => (
          "AND",
          ::prisma_client_rust::SerializedWhereValue::Object(
            ::prisma_client_rust::merge_fields(
              value
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(Into::into)
                .collect(),
            ),
          ),
        ),
        Self::Id(value) => (id::NAME, value.into()),
        Self::Status(value) => (status::NAME, value.into()),
        Self::Path(value) => (path::NAME, value.into()),
        Self::RepoIs(where_params) => (
          repo::NAME,
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "is".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
        Self::RepoIsNot(where_params) => (
          repo::NAME,
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "isNot".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
        Self::RepoDir(value) => (repo_dir::NAME, value.into()),
      };
      ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
    }
  }
  #[derive(Clone)]
  pub enum UniqueWhereParam {
    IdEquals(i32),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::IdEquals(value) => {
          Self::Id(_prisma::read_filters::IntFilter::Equals(value))
        }
      }
    }
  }
  impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
    fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
      match op {
        ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
        ::prisma_client_rust::Operator::And(value) => Self::And(value),
        ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
      }
    }
  }
  #[derive(Clone)]
  pub struct Types;
  impl ::prisma_client_rust::ModelTypes for Types {
    type Data = Data;
    type Where = WhereParam;
    type UncheckedSet = UncheckedSetParam;
    type Set = SetParam;
    type With = WithParam;
    type OrderBy = OrderByParam;
    type Cursor = UniqueWhereParam;
    const MODEL: &'static str = NAME;
    fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
      vec![
        ::prisma_client_rust::sel(id::NAME),
        ::prisma_client_rust::sel(status::NAME),
        ::prisma_client_rust::sel(path::NAME),
        ::prisma_client_rust::sel(repo_dir::NAME),
      ]
    }
  }
  pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
  pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
  pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
  pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
  pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
  pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
  pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
  pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
  pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
  pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
  pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
  pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
  pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
  #[derive(Clone)]
  pub struct Actions<'a> {
    pub client: &'a ::prisma_client_rust::PrismaClientInternals,
  }
  impl<'a> Actions<'a> {
    pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
      FindUnique::new(self.client, _where.into())
    }
    pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
      FindFirst::new(self.client, _where)
    }
    pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
      FindMany::new(self.client, _where)
    }
    pub fn create(
      self,
      status: String,
      path: String,
      repo: super::repo::UniqueWhereParam,
      mut _params: Vec<SetParam>,
    ) -> Create<'a> {
      _params.extend([
        status::set(status),
        path::set(path),
        repo::connect(repo),
      ]);
      Create::new(self.client, _params)
    }
    pub fn create_unchecked(
      self,
      status: String,
      path: String,
      repo_dir: String,
      mut _params: Vec<UncheckedSetParam>,
    ) -> Create<'a> {
      _params.extend([
        status::set(status),
        path::set(path),
        repo_dir::set(repo_dir),
      ]);
      Create::new(self.client, _params.into_iter().map(Into::into).collect())
    }
    pub fn update(
      self,
      _where: UniqueWhereParam,
      _params: Vec<SetParam>,
    ) -> Update<'a> {
      Update::new(self.client, _where.into(), _params, vec![])
    }
    pub fn update_unchecked(
      self,
      _where: UniqueWhereParam,
      _params: Vec<UncheckedSetParam>,
    ) -> Update<'a> {
      Update::new(
        self.client,
        _where.into(),
        _params.into_iter().map(Into::into).collect(),
        vec![],
      )
    }
    pub fn update_many(
      self,
      _where: Vec<WhereParam>,
      _params: Vec<SetParam>,
    ) -> UpdateMany<'a> {
      UpdateMany::new(self.client, _where, _params)
    }
    pub fn upsert(
      self,
      _where: UniqueWhereParam,
      (status, path, repo, mut _params): (
        String,
        String,
        super::repo::UniqueWhereParam,
        Vec<SetParam>,
      ),
      _update: Vec<SetParam>,
    ) -> Upsert<'a> {
      _params.extend([
        status::set(status),
        path::set(path),
        repo::connect(repo),
      ]);
      Upsert::new(self.client, _where.into(), _params, _update)
    }
    pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
      Delete::new(self.client, _where.into(), vec![])
    }
    pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
      DeleteMany::new(self.client, _where)
    }
    pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
      Count::new(self.client, _where)
    }
  }
}
pub mod branch {
  use super::_prisma::*;
  use super::*;
  pub const NAME: &str = "Branch";
  pub mod id {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "id";
    pub struct Set(pub i32);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetId(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::Id(v)
      }
    }
    pub fn set<T: From<Set>>(value: i32) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Id(direction)
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
      UniqueWhereParam::IdEquals(value).into()
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::IntFilter,
      Id,
      {
        fn in_vec(_: Vec<i32>) -> InVec;
        fn not_in_vec(_: Vec<i32>) -> NotInVec;
        fn lt(_: i32) -> Lt;
        fn lte(_: i32) -> Lte;
        fn gt(_: i32) -> Gt;
        fn gte(_: i32) -> Gte;
        fn not(_: i32) -> Not;
      }
    );
    pub fn increment(value: i32) -> SetParam {
      SetParam::IncrementId(value)
    }
    pub fn decrement(value: i32) -> SetParam {
      SetParam::DecrementId(value)
    }
    pub fn multiply(value: i32) -> SetParam {
      SetParam::MultiplyId(value)
    }
    pub fn divide(value: i32) -> SetParam {
      SetParam::DivideId(value)
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Id(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Id(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod name {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "name";
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetName(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::Name(v)
      }
    }
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Name(direction)
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::StringFilter,
      Name,
      {
        fn in_vec(_: Vec<String>) -> InVec;
        fn not_in_vec(_: Vec<String>) -> NotInVec;
        fn lt(_: String) -> Lt;
        fn lte(_: String) -> Lte;
        fn gt(_: String) -> Gt;
        fn gte(_: String) -> Gte;
        fn contains(_: String) -> Contains;
        fn starts_with(_: String) -> StartsWith;
        fn ends_with(_: String) -> EndsWith;
        fn not(_: String) -> Not;
      }
    );
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Name(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Name(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod branch_type {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "branch_type";
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetBranchType(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::BranchType(v)
      }
    }
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::BranchType(direction)
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::BranchType(_prisma::read_filters::StringFilter::Equals(value))
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::StringFilter,
      BranchType,
      {
        fn in_vec(_: Vec<String>) -> InVec;
        fn not_in_vec(_: Vec<String>) -> NotInVec;
        fn lt(_: String) -> Lt;
        fn lte(_: String) -> Lte;
        fn gt(_: String) -> Gt;
        fn gte(_: String) -> Gte;
        fn contains(_: String) -> Contains;
        fn starts_with(_: String) -> StartsWith;
        fn ends_with(_: String) -> EndsWith;
        fn not(_: String) -> Not;
      }
    );
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::BranchType(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::BranchType(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod is_head {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "is_head";
    pub struct Set(pub bool);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetIsHead(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::IsHead(v)
      }
    }
    pub fn set<T: From<Set>>(value: bool) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::IsHead(direction)
    }
    pub fn equals(value: bool) -> WhereParam {
      WhereParam::IsHead(_prisma::read_filters::BoolFilter::Equals(value))
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::BoolFilter,
      IsHead,
      {
        fn not(_: bool) -> Not;
      }
    );
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::IsHead(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::IsHead(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod upstream {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "upstream";
    pub struct Set(pub Option<String>);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetUpstream(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::Upstream(v)
      }
    }
    pub fn set<T: From<Set>>(value: Option<String>) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Upstream(direction)
    }
    pub fn equals(value: Option<String>) -> WhereParam {
      WhereParam::Upstream(_prisma::read_filters::StringNullableFilter::Equals(
        value,
      ))
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::StringNullableFilter,
      Upstream,
      {
        fn in_vec(_: Vec<String>) -> InVec;
        fn not_in_vec(_: Vec<String>) -> NotInVec;
        fn lt(_: String) -> Lt;
        fn lte(_: String) -> Lte;
        fn gt(_: String) -> Gt;
        fn gte(_: String) -> Gte;
        fn contains(_: String) -> Contains;
        fn starts_with(_: String) -> StartsWith;
        fn ends_with(_: String) -> EndsWith;
        fn not(_: Option<String>) -> Not;
      }
    );
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Upstream(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Upstream(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod repo_dir {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "repoDir";
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetRepoDir(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::RepoDir(v)
      }
    }
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::RepoDir(direction)
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::RepoDir(_prisma::read_filters::StringFilter::Equals(value))
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::StringFilter,
      RepoDir,
      {
        fn in_vec(_: Vec<String>) -> InVec;
        fn not_in_vec(_: Vec<String>) -> NotInVec;
        fn lt(_: String) -> Lt;
        fn lte(_: String) -> Lte;
        fn gt(_: String) -> Gt;
        fn gte(_: String) -> Gte;
        fn contains(_: String) -> Contains;
        fn starts_with(_: String) -> StartsWith;
        fn ends_with(_: String) -> EndsWith;
        fn not(_: String) -> Not;
      }
    );
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::RepoDir(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::RepoDir(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod repo {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "Repo";
    pub struct Fetch(pub repo::UniqueArgs);
    impl Fetch {
      pub fn with(mut self, params: impl Into<repo::WithParam>) -> Self {
        self.0 = self.0.with(params.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(Fetch(v): Fetch) -> Self {
        WithParam::Repo(v)
      }
    }
    pub fn fetch() -> Fetch {
      Fetch(repo::UniqueArgs::new())
    }
    pub struct Connect(repo::UniqueWhereParam);
    impl From<Connect> for SetParam {
      fn from(Connect(v): Connect) -> Self {
        Self::ConnectRepo(v)
      }
    }
    pub fn connect<T: From<Connect>>(value: repo::UniqueWhereParam) -> T {
      Connect(value).into()
    }
    pub fn is(value: Vec<repo::WhereParam>) -> WhereParam {
      WhereParam::RepoIs(value)
    }
    pub fn is_not(value: Vec<repo::WhereParam>) -> WhereParam {
      WhereParam::RepoIsNot(value)
    }
    pub enum Include {
      Select(Vec<repo::SelectParam>),
      Include(Vec<repo::IncludeParam>),
      Fetch,
    }
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Repo(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        let selections = match self {
          Self::Select(selections) => {
            selections.into_iter().map(|s| s.to_selection()).collect()
          }
          Self::Include(selections) => {
            let mut nested_selections = < repo :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
            nested_selections
              .extend(selections.into_iter().map(|s| s.to_selection()));
            nested_selections
          }
          Self::Fetch => {
            <repo::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
            )
          }
        };
        ::prisma_client_rust::Selection::new("Repo", None, [], selections)
      }
      pub fn select(nested_selections: Vec<repo::SelectParam>) -> Self {
        Self::Select(nested_selections)
      }
      pub fn include(nested_selections: Vec<repo::IncludeParam>) -> Self {
        Self::Include(nested_selections)
      }
    }
    pub enum Select {
      Select(Vec<repo::SelectParam>),
      Include(Vec<repo::IncludeParam>),
      Fetch,
    }
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Repo(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        let selections = match self {
          Self::Select(selections) => {
            selections.into_iter().map(|s| s.to_selection()).collect()
          }
          Self::Include(selections) => {
            let mut nested_selections = vec![];
            nested_selections
              .extend(selections.into_iter().map(|s| s.to_selection()));
            nested_selections
          }
          Self::Fetch => {
            <repo::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
            )
          }
        };
        ::prisma_client_rust::Selection::new("Repo", None, [], selections)
      }
      pub fn select(nested_selections: Vec<repo::SelectParam>) -> Self {
        Self::Select(nested_selections)
      }
      pub fn include(nested_selections: Vec<repo::IncludeParam>) -> Self {
        Self::Include(nested_selections)
      }
    }
  }
  pub fn name_repo_dir<T: From<UniqueWhereParam>>(
    name: String,
    repo_dir: String,
  ) -> T {
    UniqueWhereParam::NameRepoDirEquals(name, repo_dir).into()
  }
  pub fn create(
    name: String,
    branch_type: String,
    is_head: bool,
    repo: super::repo::UniqueWhereParam,
    _params: Vec<SetParam>,
  ) -> (
    String,
    String,
    bool,
    super::repo::UniqueWhereParam,
    Vec<SetParam>,
  ) {
    (name, branch_type, is_head, repo, _params)
  }
  pub fn create_unchecked(
    name: String,
    branch_type: String,
    is_head: bool,
    repo_dir: String,
    _params: Vec<SetParam>,
  ) -> (String, String, bool, String, Vec<SetParam>) {
    (name, branch_type, is_head, repo_dir, _params)
  }
  #[macro_export]
  macro_rules ! _select_branch { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: branch :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: branch :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: branch :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: branch :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: branch :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: branch :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , branch_type , is_head , upstream , repo_dir , repo } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: branch :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: branch :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: branch :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: branch :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: branch :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: branch :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "branch_type" , "is_head" , "upstream" , "repoDir" , "Repo"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: branch :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; name) => { String } ; (@ field_type ; branch_type) => { String } ; (@ field_type ; is_head) => { bool } ; (@ field_type ; upstream) => { Option < String > } ; (@ field_type ; repo_dir) => { String } ; (@ field_type ; repo : $ selection_mode : ident { $ ($ selections : tt) + }) => { repo :: Data } ; (@ field_type ; repo) => { crate :: prisma :: repo :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Branch" , available relations are "id, name, branch_type, is_head, upstream, repo_dir, repo")) } ; (@ field_module ; repo : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: repo :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: branch :: SelectParam > :: into (crate :: prisma :: branch :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: branch :: SelectParam > :: into (crate :: prisma :: branch :: name :: Select) } ; (@ selection_field_to_selection_param ; branch_type) => { Into :: < crate :: prisma :: branch :: SelectParam > :: into (crate :: prisma :: branch :: branch_type :: Select) } ; (@ selection_field_to_selection_param ; is_head) => { Into :: < crate :: prisma :: branch :: SelectParam > :: into (crate :: prisma :: branch :: is_head :: Select) } ; (@ selection_field_to_selection_param ; upstream) => { Into :: < crate :: prisma :: branch :: SelectParam > :: into (crate :: prisma :: branch :: upstream :: Select) } ; (@ selection_field_to_selection_param ; repo_dir) => { Into :: < crate :: prisma :: branch :: SelectParam > :: into (crate :: prisma :: branch :: repo_dir :: Select) } ; (@ selection_field_to_selection_param ; repo $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: branch :: SelectParam > :: into (crate :: prisma :: branch :: repo :: Select :: $ selection_mode (crate :: prisma :: repo :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; repo $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: branch :: SelectParam > :: into (crate :: prisma :: branch :: repo :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: branch :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; branch_type) => { "branch_type" } ; (@ field_serde_name ; is_head) => { "is_head" } ; (@ field_serde_name ; upstream) => { "upstream" } ; (@ field_serde_name ; repo_dir) => { "repoDir" } ; (@ field_serde_name ; repo) => { "Repo" } ; }
  pub use _select_branch as select;
  pub enum SelectParam {
    Id(id::Select),
    Name(name::Select),
    BranchType(branch_type::Select),
    IsHead(is_head::Select),
    Upstream(upstream::Select),
    RepoDir(repo_dir::Select),
    Repo(repo::Select),
  }
  impl SelectParam {
    pub fn to_selection(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Id(data) => data.to_selection(),
        Self::Name(data) => data.to_selection(),
        Self::BranchType(data) => data.to_selection(),
        Self::IsHead(data) => data.to_selection(),
        Self::Upstream(data) => data.to_selection(),
        Self::RepoDir(data) => data.to_selection(),
        Self::Repo(data) => data.to_selection(),
      }
    }
  }
  #[macro_export]
  macro_rules ! _include_branch { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: branch :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: branch :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: branch :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: branch :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: branch :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: branch :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: branch :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: branch :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { repo } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub name : String , pub branch_type : String , pub is_head : bool , pub upstream : Option < String > , pub repo_dir : String , $ (pub $ field : crate :: prisma :: branch :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (branch_type) , stringify ! (is_head) , stringify ! (upstream) , stringify ! (repo_dir)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: branch :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: branch :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: branch :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: branch :: branch_type :: NAME , & self . branch_type) ? ; state . serialize_field (crate :: prisma :: branch :: is_head :: NAME , & self . is_head) ? ; state . serialize_field (crate :: prisma :: branch :: upstream :: NAME , & self . upstream) ? ; state . serialize_field (crate :: prisma :: branch :: repo_dir :: NAME , & self . repo_dir) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , branch_type , is_head , upstream , repo_dir } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: branch :: $ field :: NAME) , + , crate :: prisma :: branch :: id :: NAME , crate :: prisma :: branch :: name :: NAME , crate :: prisma :: branch :: branch_type :: NAME , crate :: prisma :: branch :: is_head :: NAME , crate :: prisma :: branch :: upstream :: NAME , crate :: prisma :: branch :: repo_dir :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: branch :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: branch :: id :: NAME => Ok (Field :: id) , crate :: prisma :: branch :: name :: NAME => Ok (Field :: name) , crate :: prisma :: branch :: branch_type :: NAME => Ok (Field :: branch_type) , crate :: prisma :: branch :: is_head :: NAME => Ok (Field :: is_head) , crate :: prisma :: branch :: upstream :: NAME => Ok (Field :: upstream) , crate :: prisma :: branch :: repo_dir :: NAME => Ok (Field :: repo_dir) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut branch_type = None ; let mut is_head = None ; let mut upstream = None ; let mut repo_dir = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: branch :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: branch :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: branch_type => { if branch_type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: branch :: branch_type :: NAME)) ; } branch_type = Some (map . next_value () ?) ; } Field :: is_head => { if is_head . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: branch :: is_head :: NAME)) ; } is_head = Some (map . next_value () ?) ; } Field :: upstream => { if upstream . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: branch :: upstream :: NAME)) ; } upstream = Some (map . next_value () ?) ; } Field :: repo_dir => { if repo_dir . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: branch :: repo_dir :: NAME)) ; } repo_dir = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: branch :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: branch :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: branch :: id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: branch :: name :: NAME)) ? ; let branch_type = branch_type . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: branch :: branch_type :: NAME)) ? ; let is_head = is_head . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: branch :: is_head :: NAME)) ? ; let upstream = upstream . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: branch :: upstream :: NAME)) ? ; let repo_dir = repo_dir . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: branch :: repo_dir :: NAME)) ? ; Ok (Data { id , name , branch_type , is_head , upstream , repo_dir , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "branch_type" , "is_head" , "upstream" , "repoDir" , "Repo"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: branch :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; repo : $ selection_mode : ident { $ ($ selections : tt) + }) => { repo :: Data } ; (@ field_type ; repo) => { crate :: prisma :: repo :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Branch" , available relations are "repo")) } ; (@ field_module ; repo : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: repo :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; repo $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: branch :: IncludeParam > :: into (crate :: prisma :: branch :: repo :: Include :: $ selection_mode (crate :: prisma :: repo :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; repo $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: branch :: IncludeParam > :: into (crate :: prisma :: branch :: repo :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: branch :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; branch_type) => { "branch_type" } ; (@ field_serde_name ; is_head) => { "is_head" } ; (@ field_serde_name ; upstream) => { "upstream" } ; (@ field_serde_name ; repo_dir) => { "repoDir" } ; (@ field_serde_name ; repo) => { "Repo" } ; }
  pub use _include_branch as include;
  pub enum IncludeParam {
    Id(id::Include),
    Name(name::Include),
    BranchType(branch_type::Include),
    IsHead(is_head::Include),
    Upstream(upstream::Include),
    RepoDir(repo_dir::Include),
    Repo(repo::Include),
  }
  impl IncludeParam {
    pub fn to_selection(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Id(data) => data.to_selection(),
        Self::Name(data) => data.to_selection(),
        Self::BranchType(data) => data.to_selection(),
        Self::IsHead(data) => data.to_selection(),
        Self::Upstream(data) => data.to_selection(),
        Self::RepoDir(data) => data.to_selection(),
        Self::Repo(data) => data.to_selection(),
      }
    }
  }
  #[macro_export]
  macro_rules ! _partial_unchecked_branch { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: branch struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "name")] pub name : String , # [serde (rename = "branch_type")] pub branch_type : String , # [serde (rename = "is_head")] pub is_head : bool , # [serde (rename = "upstream")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub upstream : Option < String > , # [serde (rename = "repoDir")] pub repo_dir : String } [$ ($ scalar_field) , +] } } ; }
  pub use _partial_unchecked_branch as partial_unchecked;
  #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
  pub struct Data {
    #[serde(rename = "id")]
    pub id: i32,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "branch_type")]
    pub branch_type: String,
    #[serde(rename = "is_head")]
    pub is_head: bool,
    #[serde(rename = "upstream")]
    pub upstream: Option<String>,
    #[serde(rename = "repoDir")]
    pub repo_dir: String,
    #[serde(rename = "Repo")]
    pub repo: Option<Box<super::repo::Data>>,
  }
  impl Data {
    pub fn repo(
      &self,
    ) -> Result<&super::repo::Data, ::prisma_client_rust::RelationNotFetchedError>
    {
      self
        .repo
        .as_ref()
        .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
          stringify!(repo),
        ))
        .map(|v| v.as_ref())
    }
  }
  #[derive(Clone)]
  pub enum WithParam {
    Repo(super::repo::UniqueArgs),
  }
  impl Into<::prisma_client_rust::Selection> for WithParam {
    fn into(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Repo(args) => {
          let mut selections = < super :: repo :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
          selections.extend(
            args
              .with_params
              .into_iter()
              .map(Into::<::prisma_client_rust::Selection>::into),
          );
          ::prisma_client_rust::Selection::new(repo::NAME, None, [], selections)
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum SetParam {
    SetId(i32),
    IncrementId(i32),
    DecrementId(i32),
    MultiplyId(i32),
    DivideId(i32),
    SetName(String),
    SetBranchType(String),
    SetIsHead(bool),
    SetUpstream(Option<String>),
    SetRepoDir(String),
    ConnectRepo(super::repo::UniqueWhereParam),
  }
  impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
    fn from(param: SetParam) -> Self {
      match param {
        SetParam::SetId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Int(value as i64),
        ),
        SetParam::IncrementId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "increment".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::DecrementId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "decrement".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::MultiplyId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "multiply".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::DivideId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "divide".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::SetName(value) => (
          name::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(value),
        ),
        SetParam::SetBranchType(value) => (
          branch_type::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(value),
        ),
        SetParam::SetIsHead(value) => (
          is_head::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Boolean(value),
        ),
        SetParam::SetUpstream(value) => (
          upstream::NAME.to_string(),
          value
            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
        ),
        SetParam::SetRepoDir(value) => (
          repo_dir::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(value),
        ),
        SetParam::ConnectRepo(where_param) => (
          repo::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "connect".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              [where_param]
                .into_iter()
                .map(Into::<super::repo::WhereParam>::into)
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
      }
    }
  }
  #[derive(Clone)]
  pub enum UncheckedSetParam {
    Id(i32),
    Name(String),
    BranchType(String),
    IsHead(bool),
    Upstream(Option<String>),
    RepoDir(String),
  }
  impl From<UncheckedSetParam> for SetParam {
    fn from(param: UncheckedSetParam) -> Self {
      match param {
        UncheckedSetParam::Id(value) => Self::SetId(value),
        UncheckedSetParam::Name(value) => Self::SetName(value),
        UncheckedSetParam::BranchType(value) => Self::SetBranchType(value),
        UncheckedSetParam::IsHead(value) => Self::SetIsHead(value),
        UncheckedSetParam::Upstream(value) => Self::SetUpstream(value),
        UncheckedSetParam::RepoDir(value) => Self::SetRepoDir(value),
      }
    }
  }
  #[derive(Clone)]
  pub enum OrderByParam {
    Id(::prisma_client_rust::Direction),
    Name(::prisma_client_rust::Direction),
    BranchType(::prisma_client_rust::Direction),
    IsHead(::prisma_client_rust::Direction),
    Upstream(::prisma_client_rust::Direction),
    RepoDir(::prisma_client_rust::Direction),
  }
  impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
    fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
      match self {
        Self::Id(direction) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::Name(direction) => (
          name::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::BranchType(direction) => (
          branch_type::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::IsHead(direction) => (
          is_head::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::Upstream(direction) => (
          upstream::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::RepoDir(direction) => (
          repo_dir::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
      }
    }
  }
  #[derive(Clone)]
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    NameRepoDirEquals(String, String),
    Id(_prisma::read_filters::IntFilter),
    Name(_prisma::read_filters::StringFilter),
    BranchType(_prisma::read_filters::StringFilter),
    IsHead(_prisma::read_filters::BoolFilter),
    Upstream(_prisma::read_filters::StringNullableFilter),
    RepoDir(_prisma::read_filters::StringFilter),
    RepoIs(Vec<super::repo::WhereParam>),
    RepoIsNot(Vec<super::repo::WhereParam>),
  }
  impl ::prisma_client_rust::WhereInput for WhereParam {
    fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
      let (name, value) = match self {
        Self::Not(value) => (
          "NOT",
          ::prisma_client_rust::SerializedWhereValue::Object(
            ::prisma_client_rust::merge_fields(
              value
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(Into::into)
                .collect(),
            ),
          ),
        ),
        Self::Or(value) => (
          "OR",
          ::prisma_client_rust::SerializedWhereValue::List(
            value
              .into_iter()
              .map(::prisma_client_rust::WhereInput::serialize)
              .map(Into::into)
              .map(|v| vec![v])
              .map(::prisma_client_rust::PrismaValue::Object)
              .collect(),
          ),
        ),
        Self::And(value) => (
          "AND",
          ::prisma_client_rust::SerializedWhereValue::Object(
            ::prisma_client_rust::merge_fields(
              value
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(Into::into)
                .collect(),
            ),
          ),
        ),
        Self::NameRepoDirEquals(name, repo_dir) => (
          "name_repoDir",
          ::prisma_client_rust::SerializedWhereValue::Object(vec![
            (
              name::NAME.to_string(),
              ::prisma_client_rust::PrismaValue::String(name),
            ),
            (
              repo_dir::NAME.to_string(),
              ::prisma_client_rust::PrismaValue::String(repo_dir),
            ),
          ]),
        ),
        Self::Id(value) => (id::NAME, value.into()),
        Self::Name(value) => (name::NAME, value.into()),
        Self::BranchType(value) => (branch_type::NAME, value.into()),
        Self::IsHead(value) => (is_head::NAME, value.into()),
        Self::Upstream(value) => (upstream::NAME, value.into()),
        Self::RepoDir(value) => (repo_dir::NAME, value.into()),
        Self::RepoIs(where_params) => (
          repo::NAME,
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "is".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
        Self::RepoIsNot(where_params) => (
          repo::NAME,
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "isNot".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
      };
      ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
    }
  }
  #[derive(Clone)]
  pub enum UniqueWhereParam {
    NameRepoDirEquals(String, String),
    IdEquals(i32),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::NameRepoDirEquals(name, repo_dir) => {
          Self::NameRepoDirEquals(name, repo_dir)
        }
        UniqueWhereParam::IdEquals(value) => {
          Self::Id(_prisma::read_filters::IntFilter::Equals(value))
        }
      }
    }
  }
  impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
    fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
      match op {
        ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
        ::prisma_client_rust::Operator::And(value) => Self::And(value),
        ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
      }
    }
  }
  #[derive(Clone)]
  pub struct Types;
  impl ::prisma_client_rust::ModelTypes for Types {
    type Data = Data;
    type Where = WhereParam;
    type UncheckedSet = UncheckedSetParam;
    type Set = SetParam;
    type With = WithParam;
    type OrderBy = OrderByParam;
    type Cursor = UniqueWhereParam;
    const MODEL: &'static str = NAME;
    fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
      vec![
        ::prisma_client_rust::sel(id::NAME),
        ::prisma_client_rust::sel(name::NAME),
        ::prisma_client_rust::sel(branch_type::NAME),
        ::prisma_client_rust::sel(is_head::NAME),
        ::prisma_client_rust::sel(upstream::NAME),
        ::prisma_client_rust::sel(repo_dir::NAME),
      ]
    }
  }
  pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
  pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
  pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
  pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
  pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
  pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
  pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
  pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
  pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
  pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
  pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
  pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
  pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
  #[derive(Clone)]
  pub struct Actions<'a> {
    pub client: &'a ::prisma_client_rust::PrismaClientInternals,
  }
  impl<'a> Actions<'a> {
    pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
      FindUnique::new(self.client, _where.into())
    }
    pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
      FindFirst::new(self.client, _where)
    }
    pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
      FindMany::new(self.client, _where)
    }
    pub fn create(
      self,
      name: String,
      branch_type: String,
      is_head: bool,
      repo: super::repo::UniqueWhereParam,
      mut _params: Vec<SetParam>,
    ) -> Create<'a> {
      _params.extend([
        name::set(name),
        branch_type::set(branch_type),
        is_head::set(is_head),
        repo::connect(repo),
      ]);
      Create::new(self.client, _params)
    }
    pub fn create_unchecked(
      self,
      name: String,
      branch_type: String,
      is_head: bool,
      repo_dir: String,
      mut _params: Vec<UncheckedSetParam>,
    ) -> Create<'a> {
      _params.extend([
        name::set(name),
        branch_type::set(branch_type),
        is_head::set(is_head),
        repo_dir::set(repo_dir),
      ]);
      Create::new(self.client, _params.into_iter().map(Into::into).collect())
    }
    pub fn update(
      self,
      _where: UniqueWhereParam,
      _params: Vec<SetParam>,
    ) -> Update<'a> {
      Update::new(self.client, _where.into(), _params, vec![])
    }
    pub fn update_unchecked(
      self,
      _where: UniqueWhereParam,
      _params: Vec<UncheckedSetParam>,
    ) -> Update<'a> {
      Update::new(
        self.client,
        _where.into(),
        _params.into_iter().map(Into::into).collect(),
        vec![],
      )
    }
    pub fn update_many(
      self,
      _where: Vec<WhereParam>,
      _params: Vec<SetParam>,
    ) -> UpdateMany<'a> {
      UpdateMany::new(self.client, _where, _params)
    }
    pub fn upsert(
      self,
      _where: UniqueWhereParam,
      (name, branch_type, is_head, repo, mut _params): (
        String,
        String,
        bool,
        super::repo::UniqueWhereParam,
        Vec<SetParam>,
      ),
      _update: Vec<SetParam>,
    ) -> Upsert<'a> {
      _params.extend([
        name::set(name),
        branch_type::set(branch_type),
        is_head::set(is_head),
        repo::connect(repo),
      ]);
      Upsert::new(self.client, _where.into(), _params, _update)
    }
    pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
      Delete::new(self.client, _where.into(), vec![])
    }
    pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
      DeleteMany::new(self.client, _where)
    }
    pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
      Count::new(self.client, _where)
    }
  }
}
pub mod git_config {
  use super::_prisma::*;
  use super::*;
  pub const NAME: &str = "gitConfig";
  pub mod id {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "id";
    pub struct Set(pub i32);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetId(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::Id(v)
      }
    }
    pub fn set<T: From<Set>>(value: i32) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Id(direction)
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
      UniqueWhereParam::IdEquals(value).into()
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::IntFilter,
      Id,
      {
        fn in_vec(_: Vec<i32>) -> InVec;
        fn not_in_vec(_: Vec<i32>) -> NotInVec;
        fn lt(_: i32) -> Lt;
        fn lte(_: i32) -> Lte;
        fn gt(_: i32) -> Gt;
        fn gte(_: i32) -> Gte;
        fn not(_: i32) -> Not;
      }
    );
    pub fn increment(value: i32) -> SetParam {
      SetParam::IncrementId(value)
    }
    pub fn decrement(value: i32) -> SetParam {
      SetParam::DecrementId(value)
    }
    pub fn multiply(value: i32) -> SetParam {
      SetParam::MultiplyId(value)
    }
    pub fn divide(value: i32) -> SetParam {
      SetParam::DivideId(value)
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Id(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Id(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod entries {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "entries";
    pub struct Fetch(pub git_config_entry::ManyArgs);
    impl Fetch {
      pub fn with(
        mut self,
        params: impl Into<git_config_entry::WithParam>,
      ) -> Self {
        self.0 = self.0.with(params.into());
        self
      }
      pub fn order_by(mut self, param: git_config_entry::OrderByParam) -> Self {
        self.0 = self.0.order_by(param);
        self
      }
      pub fn skip(mut self, value: i64) -> Self {
        self.0 = self.0.skip(value);
        self
      }
      pub fn take(mut self, value: i64) -> Self {
        self.0 = self.0.take(value);
        self
      }
      pub fn cursor(
        mut self,
        value: git_config_entry::UniqueWhereParam,
      ) -> Self {
        self.0 = self.0.cursor(value.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(Fetch(v): Fetch) -> Self {
        WithParam::Entries(v)
      }
    }
    pub fn fetch(params: Vec<git_config_entry::WhereParam>) -> Fetch {
      Fetch(git_config_entry::ManyArgs::new(params))
    }
    pub struct Connect(pub Vec<git_config_entry::UniqueWhereParam>);
    impl From<Connect> for SetParam {
      fn from(Connect(v): Connect) -> Self {
        Self::ConnectEntries(v)
      }
    }
    pub fn connect<T: From<Connect>>(
      params: Vec<git_config_entry::UniqueWhereParam>,
    ) -> T {
      Connect(params).into()
    }
    pub fn disconnect(
      params: Vec<git_config_entry::UniqueWhereParam>,
    ) -> SetParam {
      SetParam::DisconnectEntries(params)
    }
    pub fn set(params: Vec<git_config_entry::UniqueWhereParam>) -> SetParam {
      SetParam::SetEntries(params)
    }
    pub fn some(value: Vec<git_config_entry::WhereParam>) -> WhereParam {
      WhereParam::EntriesSome(value)
    }
    pub fn every(value: Vec<git_config_entry::WhereParam>) -> WhereParam {
      WhereParam::EntriesEvery(value)
    }
    pub fn none(value: Vec<git_config_entry::WhereParam>) -> WhereParam {
      WhereParam::EntriesNone(value)
    }
    pub enum Include {
      Select(
        git_config_entry::ManyArgs,
        Vec<git_config_entry::SelectParam>,
      ),
      Include(
        git_config_entry::ManyArgs,
        Vec<git_config_entry::IncludeParam>,
      ),
      Fetch(git_config_entry::ManyArgs),
    }
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Entries(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < git_config_entry :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < git_config_entry :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
        ::prisma_client_rust::Selection::new(NAME, None, args, selections)
      }
      pub fn select(
        args: git_config_entry::ManyArgs,
        nested_selections: Vec<git_config_entry::SelectParam>,
      ) -> Self {
        Self::Select(args, nested_selections)
      }
      pub fn include(
        args: git_config_entry::ManyArgs,
        nested_selections: Vec<git_config_entry::IncludeParam>,
      ) -> Self {
        Self::Include(args, nested_selections)
      }
    }
    pub enum Select {
      Select(
        git_config_entry::ManyArgs,
        Vec<git_config_entry::SelectParam>,
      ),
      Include(
        git_config_entry::ManyArgs,
        Vec<git_config_entry::IncludeParam>,
      ),
      Fetch(git_config_entry::ManyArgs),
    }
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Entries(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < git_config_entry :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
        ::prisma_client_rust::Selection::new(NAME, None, args, selections)
      }
      pub fn select(
        args: git_config_entry::ManyArgs,
        nested_selections: Vec<git_config_entry::SelectParam>,
      ) -> Self {
        Self::Select(args, nested_selections)
      }
      pub fn include(
        args: git_config_entry::ManyArgs,
        nested_selections: Vec<git_config_entry::IncludeParam>,
      ) -> Self {
        Self::Include(args, nested_selections)
      }
    }
  }
  pub fn create(_params: Vec<SetParam>) -> (Vec<SetParam>) {
    (_params)
  }
  pub fn create_unchecked(_params: Vec<SetParam>) -> (Vec<SetParam>) {
    (_params)
  }
  #[macro_export]
  macro_rules ! _select_git_config { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: git_config :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: git_config :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: git_config :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: git_config :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: git_config :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: git_config :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , entries } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: git_config :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: git_config :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: git_config :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: git_config :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: git_config :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: git_config :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "entries"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: git_config :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; entries : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < entries :: Data > } ; (@ field_type ; entries) => { Vec < crate :: prisma :: git_config_entry :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "GitConfig" , available relations are "id, entries")) } ; (@ field_module ; entries : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: git_config_entry :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: git_config :: SelectParam > :: into (crate :: prisma :: git_config :: id :: Select) } ; (@ selection_field_to_selection_param ; entries $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: git_config :: SelectParam > :: into (crate :: prisma :: git_config :: entries :: Select :: $ selection_mode (crate :: prisma :: git_config_entry :: ManyArgs :: new (crate :: prisma :: git_config_entry :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: git_config_entry :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; entries $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: git_config :: SelectParam > :: into (crate :: prisma :: git_config :: entries :: Select :: Fetch (crate :: prisma :: git_config_entry :: ManyArgs :: new (crate :: prisma :: git_config_entry :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: git_config :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; entries) => { "entries" } ; }
  pub use _select_git_config as select;
  pub enum SelectParam {
    Id(id::Select),
    Entries(entries::Select),
  }
  impl SelectParam {
    pub fn to_selection(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Id(data) => data.to_selection(),
        Self::Entries(data) => data.to_selection(),
      }
    }
  }
  #[macro_export]
  macro_rules ! _include_git_config { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: git_config :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: git_config :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: git_config :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: git_config :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: git_config :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: git_config :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: git_config :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: git_config :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { entries } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , $ (pub $ field : crate :: prisma :: git_config :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: git_config :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: git_config :: id :: NAME , & self . id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: git_config :: $ field :: NAME) , + , crate :: prisma :: git_config :: id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: git_config :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: git_config :: id :: NAME => Ok (Field :: id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: git_config :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: git_config :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: git_config :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: git_config :: id :: NAME)) ? ; Ok (Data { id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "entries"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: git_config :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; entries : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < entries :: Data > } ; (@ field_type ; entries) => { Vec < crate :: prisma :: git_config_entry :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "GitConfig" , available relations are "entries")) } ; (@ field_module ; entries : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: git_config_entry :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; entries $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: git_config :: IncludeParam > :: into (crate :: prisma :: git_config :: entries :: Include :: $ selection_mode (crate :: prisma :: git_config_entry :: ManyArgs :: new (crate :: prisma :: git_config_entry :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: git_config_entry :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; entries $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: git_config :: IncludeParam > :: into (crate :: prisma :: git_config :: entries :: Include :: Fetch (crate :: prisma :: git_config_entry :: ManyArgs :: new (crate :: prisma :: git_config_entry :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: git_config :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; entries) => { "entries" } ; }
  pub use _include_git_config as include;
  pub enum IncludeParam {
    Id(id::Include),
    Entries(entries::Include),
  }
  impl IncludeParam {
    pub fn to_selection(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Id(data) => data.to_selection(),
        Self::Entries(data) => data.to_selection(),
      }
    }
  }
  #[macro_export]
  macro_rules ! _partial_unchecked_git_config { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: git_config struct $ struct_name { # [serde (rename = "id")] pub id : i32 } [$ ($ scalar_field) , +] } } ; }
  pub use _partial_unchecked_git_config as partial_unchecked;
  #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
  pub struct Data {
    #[serde(rename = "id")]
    pub id: i32,
    #[serde(rename = "entries")]
    pub entries: Option<Vec<super::git_config_entry::Data>>,
  }
  impl Data {
    pub fn entries(
      &self,
    ) -> Result<
      &Vec<super::git_config_entry::Data>,
      ::prisma_client_rust::RelationNotFetchedError,
    > {
      self.entries.as_ref().ok_or(
        ::prisma_client_rust::RelationNotFetchedError::new(stringify!(entries)),
      )
    }
  }
  #[derive(Clone)]
  pub enum WithParam {
    Entries(super::git_config_entry::ManyArgs),
  }
  impl Into<::prisma_client_rust::Selection> for WithParam {
    fn into(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Entries(args) => {
          let (arguments, mut nested_selections) = args.to_graphql();
          nested_selections . extend (< super :: git_config_entry :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
          ::prisma_client_rust::Selection::new(
            entries::NAME,
            None,
            arguments,
            nested_selections,
          )
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum SetParam {
    SetId(i32),
    IncrementId(i32),
    DecrementId(i32),
    MultiplyId(i32),
    DivideId(i32),
    ConnectEntries(Vec<super::git_config_entry::UniqueWhereParam>),
    DisconnectEntries(Vec<super::git_config_entry::UniqueWhereParam>),
    SetEntries(Vec<super::git_config_entry::UniqueWhereParam>),
  }
  impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
    fn from(param: SetParam) -> Self {
      match param {
        SetParam::SetId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Int(value as i64),
        ),
        SetParam::IncrementId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "increment".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::DecrementId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "decrement".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::MultiplyId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "multiply".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::DivideId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "divide".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::ConnectEntries(where_params) => (
          entries::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "connect".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              where_params
                .into_iter()
                .map(Into::<super::git_config_entry::WhereParam>::into)
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                .collect(),
            ),
          )]),
        ),
        SetParam::DisconnectEntries(where_params) => (
          entries::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "disconnect".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              where_params
                .into_iter()
                .map(Into::<super::git_config_entry::WhereParam>::into)
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                .collect(),
            ),
          )]),
        ),
        SetParam::SetEntries(where_params) => (
          entries::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "set".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              where_params
                .into_iter()
                .map(Into::<super::git_config_entry::WhereParam>::into)
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                .collect(),
            ),
          )]),
        ),
      }
    }
  }
  #[derive(Clone)]
  pub enum UncheckedSetParam {
    Id(i32),
  }
  impl From<UncheckedSetParam> for SetParam {
    fn from(param: UncheckedSetParam) -> Self {
      match param {
        UncheckedSetParam::Id(value) => Self::SetId(value),
      }
    }
  }
  #[derive(Clone)]
  pub enum OrderByParam {
    Id(::prisma_client_rust::Direction),
  }
  impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
    fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
      match self {
        Self::Id(direction) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
      }
    }
  }
  #[derive(Clone)]
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    Id(_prisma::read_filters::IntFilter),
    EntriesSome(Vec<super::git_config_entry::WhereParam>),
    EntriesEvery(Vec<super::git_config_entry::WhereParam>),
    EntriesNone(Vec<super::git_config_entry::WhereParam>),
  }
  impl ::prisma_client_rust::WhereInput for WhereParam {
    fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
      let (name, value) = match self {
        Self::Not(value) => (
          "NOT",
          ::prisma_client_rust::SerializedWhereValue::Object(
            ::prisma_client_rust::merge_fields(
              value
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(Into::into)
                .collect(),
            ),
          ),
        ),
        Self::Or(value) => (
          "OR",
          ::prisma_client_rust::SerializedWhereValue::List(
            value
              .into_iter()
              .map(::prisma_client_rust::WhereInput::serialize)
              .map(Into::into)
              .map(|v| vec![v])
              .map(::prisma_client_rust::PrismaValue::Object)
              .collect(),
          ),
        ),
        Self::And(value) => (
          "AND",
          ::prisma_client_rust::SerializedWhereValue::Object(
            ::prisma_client_rust::merge_fields(
              value
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(Into::into)
                .collect(),
            ),
          ),
        ),
        Self::Id(value) => (id::NAME, value.into()),
        Self::EntriesSome(where_params) => (
          entries::NAME,
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "some".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
        Self::EntriesEvery(where_params) => (
          entries::NAME,
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "every".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
        Self::EntriesNone(where_params) => (
          entries::NAME,
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "none".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
      };
      ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
    }
  }
  #[derive(Clone)]
  pub enum UniqueWhereParam {
    IdEquals(i32),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::IdEquals(value) => {
          Self::Id(_prisma::read_filters::IntFilter::Equals(value))
        }
      }
    }
  }
  impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
    fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
      match op {
        ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
        ::prisma_client_rust::Operator::And(value) => Self::And(value),
        ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
      }
    }
  }
  #[derive(Clone)]
  pub struct Types;
  impl ::prisma_client_rust::ModelTypes for Types {
    type Data = Data;
    type Where = WhereParam;
    type UncheckedSet = UncheckedSetParam;
    type Set = SetParam;
    type With = WithParam;
    type OrderBy = OrderByParam;
    type Cursor = UniqueWhereParam;
    const MODEL: &'static str = NAME;
    fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
      vec![::prisma_client_rust::sel(id::NAME)]
    }
  }
  pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
  pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
  pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
  pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
  pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
  pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
  pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
  pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
  pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
  pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
  pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
  pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
  pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
  #[derive(Clone)]
  pub struct Actions<'a> {
    pub client: &'a ::prisma_client_rust::PrismaClientInternals,
  }
  impl<'a> Actions<'a> {
    pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
      FindUnique::new(self.client, _where.into())
    }
    pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
      FindFirst::new(self.client, _where)
    }
    pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
      FindMany::new(self.client, _where)
    }
    pub fn create(self, mut _params: Vec<SetParam>) -> Create<'a> {
      _params.extend([]);
      Create::new(self.client, _params)
    }
    pub fn create_unchecked(
      self,
      mut _params: Vec<UncheckedSetParam>,
    ) -> Create<'a> {
      _params.extend([]);
      Create::new(self.client, _params.into_iter().map(Into::into).collect())
    }
    pub fn update(
      self,
      _where: UniqueWhereParam,
      _params: Vec<SetParam>,
    ) -> Update<'a> {
      Update::new(self.client, _where.into(), _params, vec![])
    }
    pub fn update_unchecked(
      self,
      _where: UniqueWhereParam,
      _params: Vec<UncheckedSetParam>,
    ) -> Update<'a> {
      Update::new(
        self.client,
        _where.into(),
        _params.into_iter().map(Into::into).collect(),
        vec![],
      )
    }
    pub fn update_many(
      self,
      _where: Vec<WhereParam>,
      _params: Vec<SetParam>,
    ) -> UpdateMany<'a> {
      UpdateMany::new(self.client, _where, _params)
    }
    pub fn upsert(
      self,
      _where: UniqueWhereParam,
      (mut _params): (Vec<SetParam>),
      _update: Vec<SetParam>,
    ) -> Upsert<'a> {
      _params.extend([]);
      Upsert::new(self.client, _where.into(), _params, _update)
    }
    pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
      Delete::new(self.client, _where.into(), vec![])
    }
    pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
      DeleteMany::new(self.client, _where)
    }
    pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
      Count::new(self.client, _where)
    }
  }
}
pub mod git_config_entry {
  use super::_prisma::*;
  use super::*;
  pub const NAME: &str = "gitConfigEntry";
  pub mod id {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "id";
    pub struct Set(pub i32);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetId(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::Id(v)
      }
    }
    pub fn set<T: From<Set>>(value: i32) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Id(direction)
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
      UniqueWhereParam::IdEquals(value).into()
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::IntFilter,
      Id,
      {
        fn in_vec(_: Vec<i32>) -> InVec;
        fn not_in_vec(_: Vec<i32>) -> NotInVec;
        fn lt(_: i32) -> Lt;
        fn lte(_: i32) -> Lte;
        fn gt(_: i32) -> Gt;
        fn gte(_: i32) -> Gte;
        fn not(_: i32) -> Not;
      }
    );
    pub fn increment(value: i32) -> SetParam {
      SetParam::IncrementId(value)
    }
    pub fn decrement(value: i32) -> SetParam {
      SetParam::DecrementId(value)
    }
    pub fn multiply(value: i32) -> SetParam {
      SetParam::MultiplyId(value)
    }
    pub fn divide(value: i32) -> SetParam {
      SetParam::DivideId(value)
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Id(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Id(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod name {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "name";
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetName(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::Name(v)
      }
    }
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Name(direction)
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
      UniqueWhereParam::NameEquals(value).into()
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::StringFilter,
      Name,
      {
        fn in_vec(_: Vec<String>) -> InVec;
        fn not_in_vec(_: Vec<String>) -> NotInVec;
        fn lt(_: String) -> Lt;
        fn lte(_: String) -> Lte;
        fn gt(_: String) -> Gt;
        fn gte(_: String) -> Gte;
        fn contains(_: String) -> Contains;
        fn starts_with(_: String) -> StartsWith;
        fn ends_with(_: String) -> EndsWith;
        fn not(_: String) -> Not;
      }
    );
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Name(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Name(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod value {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "value";
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetValue(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::Value(v)
      }
    }
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Value(direction)
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::Value(_prisma::read_filters::StringFilter::Equals(value))
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::StringFilter,
      Value,
      {
        fn in_vec(_: Vec<String>) -> InVec;
        fn not_in_vec(_: Vec<String>) -> NotInVec;
        fn lt(_: String) -> Lt;
        fn lte(_: String) -> Lte;
        fn gt(_: String) -> Gt;
        fn gte(_: String) -> Gte;
        fn contains(_: String) -> Contains;
        fn starts_with(_: String) -> StartsWith;
        fn ends_with(_: String) -> EndsWith;
        fn not(_: String) -> Not;
      }
    );
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Value(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Value(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub mod git_config {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "gitConfig";
    pub struct Fetch(pub git_config::UniqueArgs);
    impl Fetch {
      pub fn with(mut self, params: impl Into<git_config::WithParam>) -> Self {
        self.0 = self.0.with(params.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(Fetch(v): Fetch) -> Self {
        WithParam::GitConfig(v)
      }
    }
    pub fn fetch() -> Fetch {
      Fetch(git_config::UniqueArgs::new())
    }
    pub struct Connect(git_config::UniqueWhereParam);
    impl From<Connect> for SetParam {
      fn from(Connect(v): Connect) -> Self {
        Self::ConnectGitConfig(v)
      }
    }
    pub fn connect<T: From<Connect>>(value: git_config::UniqueWhereParam) -> T {
      Connect(value).into()
    }
    pub fn is(value: Vec<git_config::WhereParam>) -> WhereParam {
      WhereParam::GitConfigIs(value)
    }
    pub fn is_not(value: Vec<git_config::WhereParam>) -> WhereParam {
      WhereParam::GitConfigIsNot(value)
    }
    pub enum Include {
      Select(Vec<git_config::SelectParam>),
      Include(Vec<git_config::IncludeParam>),
      Fetch,
    }
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::GitConfig(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < git_config :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < git_config :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
        ::prisma_client_rust::Selection::new("gitConfig", None, [], selections)
      }
      pub fn select(nested_selections: Vec<git_config::SelectParam>) -> Self {
        Self::Select(nested_selections)
      }
      pub fn include(nested_selections: Vec<git_config::IncludeParam>) -> Self {
        Self::Include(nested_selections)
      }
    }
    pub enum Select {
      Select(Vec<git_config::SelectParam>),
      Include(Vec<git_config::IncludeParam>),
      Fetch,
    }
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::GitConfig(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < git_config :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
        ::prisma_client_rust::Selection::new("gitConfig", None, [], selections)
      }
      pub fn select(nested_selections: Vec<git_config::SelectParam>) -> Self {
        Self::Select(nested_selections)
      }
      pub fn include(nested_selections: Vec<git_config::IncludeParam>) -> Self {
        Self::Include(nested_selections)
      }
    }
  }
  pub mod git_config_id {
    use super::super::*;
    use super::_prisma::*;
    use super::{
      OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam,
      WithParam,
    };
    pub const NAME: &str = "gitConfigId";
    pub struct Set(pub i32);
    impl From<Set> for SetParam {
      fn from(Set(v): Set) -> Self {
        Self::SetGitConfigId(v)
      }
    }
    impl From<Set> for UncheckedSetParam {
      fn from(Set(v): Set) -> Self {
        Self::GitConfigId(v)
      }
    }
    pub fn set<T: From<Set>>(value: i32) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::GitConfigId(direction)
    }
    pub fn equals(value: i32) -> WhereParam {
      WhereParam::GitConfigId(_prisma::read_filters::IntFilter::Equals(value))
    }
    ::prisma_client_rust::scalar_where_param_fns!(
      _prisma::read_filters::IntFilter,
      GitConfigId,
      {
        fn in_vec(_: Vec<i32>) -> InVec;
        fn not_in_vec(_: Vec<i32>) -> NotInVec;
        fn lt(_: i32) -> Lt;
        fn lte(_: i32) -> Lte;
        fn gt(_: i32) -> Gt;
        fn gte(_: i32) -> Gte;
        fn not(_: i32) -> Not;
      }
    );
    pub fn increment(value: i32) -> SetParam {
      SetParam::IncrementGitConfigId(value)
    }
    pub fn decrement(value: i32) -> SetParam {
      SetParam::DecrementGitConfigId(value)
    }
    pub fn multiply(value: i32) -> SetParam {
      SetParam::MultiplyGitConfigId(value)
    }
    pub fn divide(value: i32) -> SetParam {
      SetParam::DivideGitConfigId(value)
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::GitConfigId(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::GitConfigId(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel(NAME)
      }
    }
  }
  pub fn create(
    name: String,
    value: String,
    git_config: super::git_config::UniqueWhereParam,
    _params: Vec<SetParam>,
  ) -> (
    String,
    String,
    super::git_config::UniqueWhereParam,
    Vec<SetParam>,
  ) {
    (name, value, git_config, _params)
  }
  pub fn create_unchecked(
    name: String,
    value: String,
    git_config_id: i32,
    _params: Vec<SetParam>,
  ) -> (String, String, i32, Vec<SetParam>) {
    (name, value, git_config_id, _params)
  }
  #[macro_export]
  macro_rules ! _select_git_config_entry { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: git_config_entry :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: git_config_entry :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: git_config_entry :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: git_config_entry :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: git_config_entry :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: git_config_entry :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , value , git_config , git_config_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: git_config_entry :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: git_config_entry :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: git_config_entry :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: git_config_entry :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: git_config_entry :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: git_config_entry :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "value" , "gitConfig" , "gitConfigId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: git_config_entry :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; name) => { String } ; (@ field_type ; value) => { String } ; (@ field_type ; git_config : $ selection_mode : ident { $ ($ selections : tt) + }) => { git_config :: Data } ; (@ field_type ; git_config) => { crate :: prisma :: git_config :: Data } ; (@ field_type ; git_config_id) => { i32 } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "GitConfigEntry" , available relations are "id, name, value, git_config, git_config_id")) } ; (@ field_module ; git_config : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: git_config :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: git_config_entry :: SelectParam > :: into (crate :: prisma :: git_config_entry :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: git_config_entry :: SelectParam > :: into (crate :: prisma :: git_config_entry :: name :: Select) } ; (@ selection_field_to_selection_param ; value) => { Into :: < crate :: prisma :: git_config_entry :: SelectParam > :: into (crate :: prisma :: git_config_entry :: value :: Select) } ; (@ selection_field_to_selection_param ; git_config $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: git_config_entry :: SelectParam > :: into (crate :: prisma :: git_config_entry :: git_config :: Select :: $ selection_mode (crate :: prisma :: git_config :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; git_config $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: git_config_entry :: SelectParam > :: into (crate :: prisma :: git_config_entry :: git_config :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; git_config_id) => { Into :: < crate :: prisma :: git_config_entry :: SelectParam > :: into (crate :: prisma :: git_config_entry :: git_config_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: git_config_entry :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; value) => { "value" } ; (@ field_serde_name ; git_config) => { "gitConfig" } ; (@ field_serde_name ; git_config_id) => { "gitConfigId" } ; }
  pub use _select_git_config_entry as select;
  pub enum SelectParam {
    Id(id::Select),
    Name(name::Select),
    Value(value::Select),
    GitConfig(git_config::Select),
    GitConfigId(git_config_id::Select),
  }
  impl SelectParam {
    pub fn to_selection(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Id(data) => data.to_selection(),
        Self::Name(data) => data.to_selection(),
        Self::Value(data) => data.to_selection(),
        Self::GitConfig(data) => data.to_selection(),
        Self::GitConfigId(data) => data.to_selection(),
      }
    }
  }
  #[macro_export]
  macro_rules ! _include_git_config_entry { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: git_config_entry :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: git_config_entry :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: git_config_entry :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: git_config_entry :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: git_config_entry :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: git_config_entry :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: git_config_entry :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: git_config_entry :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { git_config } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub name : String , pub value : String , pub git_config_id : i32 , $ (pub $ field : crate :: prisma :: git_config_entry :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (value) , stringify ! (git_config_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: git_config_entry :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: git_config_entry :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: git_config_entry :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: git_config_entry :: value :: NAME , & self . value) ? ; state . serialize_field (crate :: prisma :: git_config_entry :: git_config_id :: NAME , & self . git_config_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , value , git_config_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: git_config_entry :: $ field :: NAME) , + , crate :: prisma :: git_config_entry :: id :: NAME , crate :: prisma :: git_config_entry :: name :: NAME , crate :: prisma :: git_config_entry :: value :: NAME , crate :: prisma :: git_config_entry :: git_config_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: git_config_entry :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: git_config_entry :: id :: NAME => Ok (Field :: id) , crate :: prisma :: git_config_entry :: name :: NAME => Ok (Field :: name) , crate :: prisma :: git_config_entry :: value :: NAME => Ok (Field :: value) , crate :: prisma :: git_config_entry :: git_config_id :: NAME => Ok (Field :: git_config_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut value = None ; let mut git_config_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: git_config_entry :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: git_config_entry :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: value => { if value . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: git_config_entry :: value :: NAME)) ; } value = Some (map . next_value () ?) ; } Field :: git_config_id => { if git_config_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: git_config_entry :: git_config_id :: NAME)) ; } git_config_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: git_config_entry :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: git_config_entry :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: git_config_entry :: id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: git_config_entry :: name :: NAME)) ? ; let value = value . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: git_config_entry :: value :: NAME)) ? ; let git_config_id = git_config_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: git_config_entry :: git_config_id :: NAME)) ? ; Ok (Data { id , name , value , git_config_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "value" , "gitConfig" , "gitConfigId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: git_config_entry :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; git_config : $ selection_mode : ident { $ ($ selections : tt) + }) => { git_config :: Data } ; (@ field_type ; git_config) => { crate :: prisma :: git_config :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "GitConfigEntry" , available relations are "git_config")) } ; (@ field_module ; git_config : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: git_config :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; git_config $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: git_config_entry :: IncludeParam > :: into (crate :: prisma :: git_config_entry :: git_config :: Include :: $ selection_mode (crate :: prisma :: git_config :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; git_config $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: git_config_entry :: IncludeParam > :: into (crate :: prisma :: git_config_entry :: git_config :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: git_config_entry :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; value) => { "value" } ; (@ field_serde_name ; git_config) => { "gitConfig" } ; (@ field_serde_name ; git_config_id) => { "gitConfigId" } ; }
  pub use _include_git_config_entry as include;
  pub enum IncludeParam {
    Id(id::Include),
    Name(name::Include),
    Value(value::Include),
    GitConfig(git_config::Include),
    GitConfigId(git_config_id::Include),
  }
  impl IncludeParam {
    pub fn to_selection(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Id(data) => data.to_selection(),
        Self::Name(data) => data.to_selection(),
        Self::Value(data) => data.to_selection(),
        Self::GitConfig(data) => data.to_selection(),
        Self::GitConfigId(data) => data.to_selection(),
      }
    }
  }
  #[macro_export]
  macro_rules ! _partial_unchecked_git_config_entry { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: git_config_entry struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "name")] pub name : String , # [serde (rename = "value")] pub value : String , # [serde (rename = "gitConfigId")] pub git_config_id : i32 } [$ ($ scalar_field) , +] } } ; }
  pub use _partial_unchecked_git_config_entry as partial_unchecked;
  #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
  pub struct Data {
    #[serde(rename = "id")]
    pub id: i32,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "value")]
    pub value: String,
    #[serde(rename = "gitConfig")]
    pub git_config: Option<Box<super::git_config::Data>>,
    #[serde(rename = "gitConfigId")]
    pub git_config_id: i32,
  }
  impl Data {
    pub fn git_config(
      &self,
    ) -> Result<
      &super::git_config::Data,
      ::prisma_client_rust::RelationNotFetchedError,
    > {
      self
        .git_config
        .as_ref()
        .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
          stringify!(git_config),
        ))
        .map(|v| v.as_ref())
    }
  }
  #[derive(Clone)]
  pub enum WithParam {
    GitConfig(super::git_config::UniqueArgs),
  }
  impl Into<::prisma_client_rust::Selection> for WithParam {
    fn into(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::GitConfig(args) => {
          let mut selections = < super :: git_config :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
          selections.extend(
            args
              .with_params
              .into_iter()
              .map(Into::<::prisma_client_rust::Selection>::into),
          );
          ::prisma_client_rust::Selection::new(
            git_config::NAME,
            None,
            [],
            selections,
          )
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum SetParam {
    SetId(i32),
    IncrementId(i32),
    DecrementId(i32),
    MultiplyId(i32),
    DivideId(i32),
    SetName(String),
    SetValue(String),
    ConnectGitConfig(super::git_config::UniqueWhereParam),
    SetGitConfigId(i32),
    IncrementGitConfigId(i32),
    DecrementGitConfigId(i32),
    MultiplyGitConfigId(i32),
    DivideGitConfigId(i32),
  }
  impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
    fn from(param: SetParam) -> Self {
      match param {
        SetParam::SetId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Int(value as i64),
        ),
        SetParam::IncrementId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "increment".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::DecrementId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "decrement".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::MultiplyId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "multiply".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::DivideId(value) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "divide".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::SetName(value) => (
          name::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(value),
        ),
        SetParam::SetValue(value) => (
          value::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(value),
        ),
        SetParam::ConnectGitConfig(where_param) => (
          git_config::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "connect".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              [where_param]
                .into_iter()
                .map(Into::<super::git_config::WhereParam>::into)
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
        SetParam::SetGitConfigId(value) => (
          git_config_id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Int(value as i64),
        ),
        SetParam::IncrementGitConfigId(value) => (
          git_config_id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "increment".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::DecrementGitConfigId(value) => (
          git_config_id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "decrement".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::MultiplyGitConfigId(value) => (
          git_config_id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "multiply".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::DivideGitConfigId(value) => (
          git_config_id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "divide".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
      }
    }
  }
  #[derive(Clone)]
  pub enum UncheckedSetParam {
    Id(i32),
    Name(String),
    Value(String),
    GitConfigId(i32),
  }
  impl From<UncheckedSetParam> for SetParam {
    fn from(param: UncheckedSetParam) -> Self {
      match param {
        UncheckedSetParam::Id(value) => Self::SetId(value),
        UncheckedSetParam::Name(value) => Self::SetName(value),
        UncheckedSetParam::Value(value) => Self::SetValue(value),
        UncheckedSetParam::GitConfigId(value) => Self::SetGitConfigId(value),
      }
    }
  }
  #[derive(Clone)]
  pub enum OrderByParam {
    Id(::prisma_client_rust::Direction),
    Name(::prisma_client_rust::Direction),
    Value(::prisma_client_rust::Direction),
    GitConfigId(::prisma_client_rust::Direction),
  }
  impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
    fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
      match self {
        Self::Id(direction) => (
          id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::Name(direction) => (
          name::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::Value(direction) => (
          value::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::GitConfigId(direction) => (
          git_config_id::NAME.to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
      }
    }
  }
  #[derive(Clone)]
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    Id(_prisma::read_filters::IntFilter),
    Name(_prisma::read_filters::StringFilter),
    Value(_prisma::read_filters::StringFilter),
    GitConfigIs(Vec<super::git_config::WhereParam>),
    GitConfigIsNot(Vec<super::git_config::WhereParam>),
    GitConfigId(_prisma::read_filters::IntFilter),
  }
  impl ::prisma_client_rust::WhereInput for WhereParam {
    fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
      let (name, value) = match self {
        Self::Not(value) => (
          "NOT",
          ::prisma_client_rust::SerializedWhereValue::Object(
            ::prisma_client_rust::merge_fields(
              value
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(Into::into)
                .collect(),
            ),
          ),
        ),
        Self::Or(value) => (
          "OR",
          ::prisma_client_rust::SerializedWhereValue::List(
            value
              .into_iter()
              .map(::prisma_client_rust::WhereInput::serialize)
              .map(Into::into)
              .map(|v| vec![v])
              .map(::prisma_client_rust::PrismaValue::Object)
              .collect(),
          ),
        ),
        Self::And(value) => (
          "AND",
          ::prisma_client_rust::SerializedWhereValue::Object(
            ::prisma_client_rust::merge_fields(
              value
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(Into::into)
                .collect(),
            ),
          ),
        ),
        Self::Id(value) => (id::NAME, value.into()),
        Self::Name(value) => (name::NAME, value.into()),
        Self::Value(value) => (value::NAME, value.into()),
        Self::GitConfigIs(where_params) => (
          git_config::NAME,
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "is".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
        Self::GitConfigIsNot(where_params) => (
          git_config::NAME,
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "isNot".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(
                  ::prisma_client_rust::SerializedWhereInput::transform_equals,
                )
                .collect(),
            ),
          )]),
        ),
        Self::GitConfigId(value) => (git_config_id::NAME, value.into()),
      };
      ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
    }
  }
  #[derive(Clone)]
  pub enum UniqueWhereParam {
    NameEquals(String),
    IdEquals(i32),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::NameEquals(value) => {
          Self::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        UniqueWhereParam::IdEquals(value) => {
          Self::Id(_prisma::read_filters::IntFilter::Equals(value))
        }
      }
    }
  }
  impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
    fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
      match op {
        ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
        ::prisma_client_rust::Operator::And(value) => Self::And(value),
        ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
      }
    }
  }
  #[derive(Clone)]
  pub struct Types;
  impl ::prisma_client_rust::ModelTypes for Types {
    type Data = Data;
    type Where = WhereParam;
    type UncheckedSet = UncheckedSetParam;
    type Set = SetParam;
    type With = WithParam;
    type OrderBy = OrderByParam;
    type Cursor = UniqueWhereParam;
    const MODEL: &'static str = NAME;
    fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
      vec![
        ::prisma_client_rust::sel(id::NAME),
        ::prisma_client_rust::sel(name::NAME),
        ::prisma_client_rust::sel(value::NAME),
        ::prisma_client_rust::sel(git_config_id::NAME),
      ]
    }
  }
  pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
  pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
  pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
  pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
  pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
  pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
  pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
  pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
  pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
  pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
  pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
  pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
  pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
  #[derive(Clone)]
  pub struct Actions<'a> {
    pub client: &'a ::prisma_client_rust::PrismaClientInternals,
  }
  impl<'a> Actions<'a> {
    pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
      FindUnique::new(self.client, _where.into())
    }
    pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
      FindFirst::new(self.client, _where)
    }
    pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
      FindMany::new(self.client, _where)
    }
    pub fn create(
      self,
      name: String,
      value: String,
      git_config: super::git_config::UniqueWhereParam,
      mut _params: Vec<SetParam>,
    ) -> Create<'a> {
      _params.extend([
        name::set(name),
        value::set(value),
        git_config::connect(git_config),
      ]);
      Create::new(self.client, _params)
    }
    pub fn create_unchecked(
      self,
      name: String,
      value: String,
      git_config_id: i32,
      mut _params: Vec<UncheckedSetParam>,
    ) -> Create<'a> {
      _params.extend([
        name::set(name),
        value::set(value),
        git_config_id::set(git_config_id),
      ]);
      Create::new(self.client, _params.into_iter().map(Into::into).collect())
    }
    pub fn update(
      self,
      _where: UniqueWhereParam,
      _params: Vec<SetParam>,
    ) -> Update<'a> {
      Update::new(self.client, _where.into(), _params, vec![])
    }
    pub fn update_unchecked(
      self,
      _where: UniqueWhereParam,
      _params: Vec<UncheckedSetParam>,
    ) -> Update<'a> {
      Update::new(
        self.client,
        _where.into(),
        _params.into_iter().map(Into::into).collect(),
        vec![],
      )
    }
    pub fn update_many(
      self,
      _where: Vec<WhereParam>,
      _params: Vec<SetParam>,
    ) -> UpdateMany<'a> {
      UpdateMany::new(self.client, _where, _params)
    }
    pub fn upsert(
      self,
      _where: UniqueWhereParam,
      (name, value, git_config, mut _params): (
        String,
        String,
        super::git_config::UniqueWhereParam,
        Vec<SetParam>,
      ),
      _update: Vec<SetParam>,
    ) -> Upsert<'a> {
      _params.extend([
        name::set(name),
        value::set(value),
        git_config::connect(git_config),
      ]);
      Upsert::new(self.client, _where.into(), _params, _update)
    }
    pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
      Delete::new(self.client, _where.into(), vec![])
    }
    pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
      DeleteMany::new(self.client, _where)
    }
    pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
      Count::new(self.client, _where)
    }
  }
}
pub mod _prisma {
  pub struct PrismaClientBuilder {
    url: Option<String>,
    action_notifier: ::prisma_client_rust::ActionNotifier,
  }
  impl PrismaClientBuilder {
    fn new() -> Self {
      Self {
        url: None,
        action_notifier: ::prisma_client_rust::ActionNotifier::new(),
      }
    }
    pub fn with_url(mut self, url: String) -> Self {
      self.url = Some(url);
      self
    }
    pub async fn build(
      self,
    ) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
      let internals = ::prisma_client_rust::PrismaClientInternals::new(
        self.url,
        self.action_notifier,
        super::DATAMODEL_STR,
      )
      .await?;
      Ok(PrismaClient(internals))
    }
  }
  pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
  impl ::std::fmt::Debug for PrismaClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
      f.debug_struct("PrismaClient").finish()
    }
  }
  impl PrismaClient {
    pub fn _builder() -> PrismaClientBuilder {
      PrismaClientBuilder::new()
    }
    pub fn _query_raw<T: ::prisma_client_rust::Data>(
      &self,
      query: ::prisma_client_rust::Raw,
    ) -> ::prisma_client_rust::QueryRaw<T> {
      ::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
    }
    pub fn _execute_raw(
      &self,
      query: ::prisma_client_rust::Raw,
    ) -> ::prisma_client_rust::ExecuteRaw {
      ::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
    }
    pub async fn _batch<
      'batch,
      T: ::prisma_client_rust::BatchContainer<'batch, Marker>,
      Marker,
    >(
      &self,
      queries: T,
    ) -> ::prisma_client_rust::Result<
      <T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
    > {
      ::prisma_client_rust::batch(queries, &self.0).await
    }
    pub fn _transaction(
      &self,
    ) -> ::prisma_client_rust::TransactionBuilder<Self> {
      ::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
    }
    pub fn repo(&self) -> super::repo::Actions {
      super::repo::Actions { client: &self.0 }
    }
    pub fn status(&self) -> super::status::Actions {
      super::status::Actions { client: &self.0 }
    }
    pub fn branch(&self) -> super::branch::Actions {
      super::branch::Actions { client: &self.0 }
    }
    pub fn git_config(&self) -> super::git_config::Actions {
      super::git_config::Actions { client: &self.0 }
    }
    pub fn git_config_entry(&self) -> super::git_config_entry::Actions {
      super::git_config_entry::Actions { client: &self.0 }
    }
  }
  impl ::prisma_client_rust::PrismaClient for PrismaClient {
    fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
      &self.0
    }
    fn internals_mut(
      &mut self,
    ) -> &mut ::prisma_client_rust::PrismaClientInternals {
      &mut self.0
    }
    fn with_tx_id(
      &self,
      tx_id: Option<::prisma_client_rust::query_core::TxId>,
    ) -> Self {
      Self(self.0.with_tx_id(tx_id))
    }
  }
  #[derive(
    Debug,
    Clone,
    Copy,
    :: serde :: Serialize,
    :: serde :: Deserialize,
    PartialEq,
    Eq,
  )]
  pub enum BranchScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "name")]
    Name,
    #[serde(rename = "branch_type")]
    BranchType,
    #[serde(rename = "is_head")]
    IsHead,
    #[serde(rename = "upstream")]
    Upstream,
    #[serde(rename = "repoDir")]
    RepoDir,
  }
  impl ToString for BranchScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::Id => "id".to_string(),
        Self::Name => "name".to_string(),
        Self::BranchType => "branch_type".to_string(),
        Self::IsHead => "is_head".to_string(),
        Self::Upstream => "upstream".to_string(),
        Self::RepoDir => "repoDir".to_string(),
      }
    }
  }
  #[derive(
    Debug,
    Clone,
    Copy,
    :: serde :: Serialize,
    :: serde :: Deserialize,
    PartialEq,
    Eq,
  )]
  pub enum GitConfigEntryScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "name")]
    Name,
    #[serde(rename = "value")]
    Value,
    #[serde(rename = "gitConfigId")]
    GitConfigId,
  }
  impl ToString for GitConfigEntryScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::Id => "id".to_string(),
        Self::Name => "name".to_string(),
        Self::Value => "value".to_string(),
        Self::GitConfigId => "gitConfigId".to_string(),
      }
    }
  }
  #[derive(
    Debug,
    Clone,
    Copy,
    :: serde :: Serialize,
    :: serde :: Deserialize,
    PartialEq,
    Eq,
  )]
  pub enum GitConfigScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
  }
  impl ToString for GitConfigScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::Id => "id".to_string(),
      }
    }
  }
  #[derive(
    Debug,
    Clone,
    Copy,
    :: serde :: Serialize,
    :: serde :: Deserialize,
    PartialEq,
    Eq,
  )]
  pub enum RepoScalarFieldEnum {
    #[serde(rename = "dir")]
    Dir,
    #[serde(rename = "managed")]
    Managed,
    #[serde(rename = "updatedAt")]
    UpdatedAt,
    #[serde(rename = "name")]
    Name,
    #[serde(rename = "is_valid")]
    IsValid,
    #[serde(rename = "state")]
    State,
  }
  impl ToString for RepoScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::Dir => "dir".to_string(),
        Self::Managed => "managed".to_string(),
        Self::UpdatedAt => "updatedAt".to_string(),
        Self::Name => "name".to_string(),
        Self::IsValid => "is_valid".to_string(),
        Self::State => "state".to_string(),
      }
    }
  }
  #[derive(
    Debug,
    Clone,
    Copy,
    :: serde :: Serialize,
    :: serde :: Deserialize,
    PartialEq,
    Eq,
  )]
  pub enum SortOrder {
    #[serde(rename = "asc")]
    Asc,
    #[serde(rename = "desc")]
    Desc,
  }
  impl ToString for SortOrder {
    fn to_string(&self) -> String {
      match self {
        Self::Asc => "asc".to_string(),
        Self::Desc => "desc".to_string(),
      }
    }
  }
  #[derive(
    Debug,
    Clone,
    Copy,
    :: serde :: Serialize,
    :: serde :: Deserialize,
    PartialEq,
    Eq,
  )]
  pub enum StatusScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "path")]
    Path,
    #[serde(rename = "repoDir")]
    RepoDir,
  }
  impl ToString for StatusScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::Id => "id".to_string(),
        Self::Status => "status".to_string(),
        Self::Path => "path".to_string(),
        Self::RepoDir => "repoDir".to_string(),
      }
    }
  }
  #[derive(
    Debug,
    Clone,
    Copy,
    :: serde :: Serialize,
    :: serde :: Deserialize,
    PartialEq,
    Eq,
  )]
  pub enum TransactionIsolationLevel {
    #[serde(rename = "Serializable")]
    Serializable,
  }
  impl ToString for TransactionIsolationLevel {
    fn to_string(&self) -> String {
      match self {
        Self::Serializable => "Serializable".to_string(),
      }
    }
  }
  impl ::prisma_client_rust::TransactionIsolationLevel
    for TransactionIsolationLevel
  {
  }
  pub mod read_filters {
    #[derive(Clone)]
    pub enum StringFilter {
      Equals(String),
      InVec(Vec<String>),
      NotInVec(Vec<String>),
      Lt(String),
      Lte(String),
      Gt(String),
      Gte(String),
      Contains(String),
      StartsWith(String),
      EndsWith(String),
      Not(String),
    }
    impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
      fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
        match self {
          Self::Equals(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              ::prisma_client_rust::PrismaValue::String(value),
            )])
          }
          Self::InVec(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "in".to_string(),
              ::prisma_client_rust::PrismaValue::List(
                value
                  .into_iter()
                  .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                  .collect(),
              ),
            )])
          }
          Self::NotInVec(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              ::prisma_client_rust::PrismaValue::List(
                value
                  .into_iter()
                  .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                  .collect(),
              ),
            )])
          }
          Self::Lt(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "lt".to_string(),
              ::prisma_client_rust::PrismaValue::String(value),
            )])
          }
          Self::Lte(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "lte".to_string(),
              ::prisma_client_rust::PrismaValue::String(value),
            )])
          }
          Self::Gt(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "gt".to_string(),
              ::prisma_client_rust::PrismaValue::String(value),
            )])
          }
          Self::Gte(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "gte".to_string(),
              ::prisma_client_rust::PrismaValue::String(value),
            )])
          }
          Self::Contains(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              ::prisma_client_rust::PrismaValue::String(value),
            )])
          }
          Self::StartsWith(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              ::prisma_client_rust::PrismaValue::String(value),
            )])
          }
          Self::EndsWith(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              ::prisma_client_rust::PrismaValue::String(value),
            )])
          }
          Self::Not(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "not".to_string(),
              ::prisma_client_rust::PrismaValue::String(value),
            )])
          }
        }
      }
    }
    #[derive(Clone)]
    pub enum StringNullableFilter {
      Equals(Option<String>),
      InVec(Vec<String>),
      NotInVec(Vec<String>),
      Lt(String),
      Lte(String),
      Gt(String),
      Gte(String),
      Contains(String),
      StartsWith(String),
      EndsWith(String),
      Not(Option<String>),
    }
    impl Into<::prisma_client_rust::SerializedWhereValue> for StringNullableFilter {
      fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
        match self {
          Self::Equals(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              value
                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
            )])
          }
          Self::InVec(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "in".to_string(),
              ::prisma_client_rust::PrismaValue::List(
                value
                  .into_iter()
                  .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                  .collect(),
              ),
            )])
          }
          Self::NotInVec(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              ::prisma_client_rust::PrismaValue::List(
                value
                  .into_iter()
                  .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                  .collect(),
              ),
            )])
          }
          Self::Lt(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "lt".to_string(),
              ::prisma_client_rust::PrismaValue::String(value),
            )])
          }
          Self::Lte(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "lte".to_string(),
              ::prisma_client_rust::PrismaValue::String(value),
            )])
          }
          Self::Gt(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "gt".to_string(),
              ::prisma_client_rust::PrismaValue::String(value),
            )])
          }
          Self::Gte(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "gte".to_string(),
              ::prisma_client_rust::PrismaValue::String(value),
            )])
          }
          Self::Contains(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "contains".to_string(),
              ::prisma_client_rust::PrismaValue::String(value),
            )])
          }
          Self::StartsWith(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "startsWith".to_string(),
              ::prisma_client_rust::PrismaValue::String(value),
            )])
          }
          Self::EndsWith(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "endsWith".to_string(),
              ::prisma_client_rust::PrismaValue::String(value),
            )])
          }
          Self::Not(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "not".to_string(),
              value
                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
            )])
          }
        }
      }
    }
    #[derive(Clone)]
    pub enum BoolFilter {
      Equals(bool),
      Not(bool),
    }
    impl Into<::prisma_client_rust::SerializedWhereValue> for BoolFilter {
      fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
        match self {
          Self::Equals(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              ::prisma_client_rust::PrismaValue::Boolean(value),
            )])
          }
          Self::Not(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "not".to_string(),
              ::prisma_client_rust::PrismaValue::Boolean(value),
            )])
          }
        }
      }
    }
    #[derive(Clone)]
    pub enum DateTimeFilter {
      Equals(
        ::prisma_client_rust::chrono::DateTime<
          ::prisma_client_rust::chrono::FixedOffset,
        >,
      ),
      InVec(
        Vec<
          ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
          >,
        >,
      ),
      NotInVec(
        Vec<
          ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
          >,
        >,
      ),
      Lt(
        ::prisma_client_rust::chrono::DateTime<
          ::prisma_client_rust::chrono::FixedOffset,
        >,
      ),
      Lte(
        ::prisma_client_rust::chrono::DateTime<
          ::prisma_client_rust::chrono::FixedOffset,
        >,
      ),
      Gt(
        ::prisma_client_rust::chrono::DateTime<
          ::prisma_client_rust::chrono::FixedOffset,
        >,
      ),
      Gte(
        ::prisma_client_rust::chrono::DateTime<
          ::prisma_client_rust::chrono::FixedOffset,
        >,
      ),
      Not(
        ::prisma_client_rust::chrono::DateTime<
          ::prisma_client_rust::chrono::FixedOffset,
        >,
      ),
    }
    impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
      fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
        match self {
          Self::Equals(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              ::prisma_client_rust::PrismaValue::DateTime(value),
            )])
          }
          Self::InVec(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "in".to_string(),
              ::prisma_client_rust::PrismaValue::List(
                value
                  .into_iter()
                  .map(|value| {
                    ::prisma_client_rust::PrismaValue::DateTime(value)
                  })
                  .collect(),
              ),
            )])
          }
          Self::NotInVec(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              ::prisma_client_rust::PrismaValue::List(
                value
                  .into_iter()
                  .map(|value| {
                    ::prisma_client_rust::PrismaValue::DateTime(value)
                  })
                  .collect(),
              ),
            )])
          }
          Self::Lt(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "lt".to_string(),
              ::prisma_client_rust::PrismaValue::DateTime(value),
            )])
          }
          Self::Lte(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "lte".to_string(),
              ::prisma_client_rust::PrismaValue::DateTime(value),
            )])
          }
          Self::Gt(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "gt".to_string(),
              ::prisma_client_rust::PrismaValue::DateTime(value),
            )])
          }
          Self::Gte(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "gte".to_string(),
              ::prisma_client_rust::PrismaValue::DateTime(value),
            )])
          }
          Self::Not(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "not".to_string(),
              ::prisma_client_rust::PrismaValue::DateTime(value),
            )])
          }
        }
      }
    }
    #[derive(Clone)]
    pub enum IntFilter {
      Equals(i32),
      InVec(Vec<i32>),
      NotInVec(Vec<i32>),
      Lt(i32),
      Lte(i32),
      Gt(i32),
      Gte(i32),
      Not(i32),
    }
    impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
      fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
        match self {
          Self::Equals(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "equals".to_string(),
              ::prisma_client_rust::PrismaValue::Int(value as i64),
            )])
          }
          Self::InVec(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "in".to_string(),
              ::prisma_client_rust::PrismaValue::List(
                value
                  .into_iter()
                  .map(|value| {
                    ::prisma_client_rust::PrismaValue::Int(value as i64)
                  })
                  .collect(),
              ),
            )])
          }
          Self::NotInVec(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "notIn".to_string(),
              ::prisma_client_rust::PrismaValue::List(
                value
                  .into_iter()
                  .map(|value| {
                    ::prisma_client_rust::PrismaValue::Int(value as i64)
                  })
                  .collect(),
              ),
            )])
          }
          Self::Lt(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "lt".to_string(),
              ::prisma_client_rust::PrismaValue::Int(value as i64),
            )])
          }
          Self::Lte(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "lte".to_string(),
              ::prisma_client_rust::PrismaValue::Int(value as i64),
            )])
          }
          Self::Gt(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "gt".to_string(),
              ::prisma_client_rust::PrismaValue::Int(value as i64),
            )])
          }
          Self::Gte(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "gte".to_string(),
              ::prisma_client_rust::PrismaValue::Int(value as i64),
            )])
          }
          Self::Not(value) => {
            ::prisma_client_rust::SerializedWhereValue::Object(vec![(
              "not".to_string(),
              ::prisma_client_rust::PrismaValue::Int(value as i64),
            )])
          }
        }
      }
    }
  }
}
pub use _prisma::*;
